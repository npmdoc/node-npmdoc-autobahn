<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/crossbario/autobahn-js#readme"

    >autobahn (v0.12.0)</a>
</h1>
<h4>An implementation of The Web Application Messaging Protocol (WAMP).</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn">module autobahn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Connection">
            function <span class="apidocSignatureSpan">autobahn.</span>Connection
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Error">
            function <span class="apidocSignatureSpan">autobahn.</span>Error
            <span class="apidocSignatureSpan">(error, args, kwargs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Event">
            function <span class="apidocSignatureSpan">autobahn.</span>Event
            <span class="apidocSignatureSpan">(publication, topic, publisher, publisher_authid, publisher_authrole)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Invocation">
            function <span class="apidocSignatureSpan">autobahn.</span>Invocation
            <span class="apidocSignatureSpan">(procedure, progress, caller, caller_authid, caller_authrole)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Publication">
            function <span class="apidocSignatureSpan">autobahn.</span>Publication
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Registration">
            function <span class="apidocSignatureSpan">autobahn.</span>Registration
            <span class="apidocSignatureSpan">(procedure, endpoint, options, session, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Result">
            function <span class="apidocSignatureSpan">autobahn.</span>Result
            <span class="apidocSignatureSpan">(args, kwargs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session">
            function <span class="apidocSignatureSpan">autobahn.</span>Session
            <span class="apidocSignatureSpan">(socket, defer, onchallenge)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Subscription">
            function <span class="apidocSignatureSpan">autobahn.</span>Subscription
            <span class="apidocSignatureSpan">(topic, handler, options, session, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.auth_persona">
            function <span class="apidocSignatureSpan">autobahn.</span>auth_persona
            <span class="apidocSignatureSpan">(session, user, extra)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder">
            function <span class="apidocSignatureSpan">autobahn.</span>msgpack.Decoder
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Encoder">
            function <span class="apidocSignatureSpan">autobahn.</span>msgpack.Encoder
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createDecodeStream">
            function <span class="apidocSignatureSpan">autobahn.</span>msgpack.createDecodeStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createEncodeStream">
            function <span class="apidocSignatureSpan">autobahn.</span>msgpack.createEncodeStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.CBORSerializer">
            function <span class="apidocSignatureSpan">autobahn.</span>serializer.CBORSerializer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.JSONSerializer">
            function <span class="apidocSignatureSpan">autobahn.</span>serializer.JSONSerializer
            <span class="apidocSignatureSpan">(replacer, reviver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.MsgpackSerializer">
            function <span class="apidocSignatureSpan">autobahn.</span>serializer.MsgpackSerializer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when">
            function <span class="apidocSignatureSpan">autobahn.</span>when
            <span class="apidocSignatureSpan">(x, onFulfilled, onRejected, onProgress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise">
            function <span class="apidocSignatureSpan">autobahn.</span>when.Promise
            <span class="apidocSignatureSpan">(resolver, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.TimeoutError">
            function <span class="apidocSignatureSpan">autobahn.</span>when.TimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>autobahn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>Connection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>Registration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>Session.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>Subscription.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>auth_cra</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>cbor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>cbor.leveldb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>connection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>log</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>longpoll</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>msgpack</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>msgpack.Decoder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>msgpack.Encoder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>msgpack.createDecodeStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>msgpack.createEncodeStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>persona</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>rawsocket</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>serializer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>serializer.CBORSerializer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>serializer.JSONSerializer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>serializer.MsgpackSerializer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>session</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>transports</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>websocket</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>when.Promise.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.</span>when.TimeoutError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">autobahn.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.Connection">module autobahn.Connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Connection.Connection">
            function <span class="apidocSignatureSpan">autobahn.</span>Connection
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.Connection.prototype">module autobahn.Connection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Connection.prototype._autoreconnect_advance">
            function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_autoreconnect_advance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Connection.prototype._autoreconnect_reset">
            function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_autoreconnect_reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Connection.prototype._autoreconnect_reset_timer">
            function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_autoreconnect_reset_timer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Connection.prototype._create_transport">
            function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_create_transport
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Connection.prototype._init_transport_factories">
            function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_init_transport_factories
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Connection.prototype.close">
            function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>close
            <span class="apidocSignatureSpan">(reason, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Connection.prototype.open">
            function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.Registration">module autobahn.Registration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Registration.Registration">
            function <span class="apidocSignatureSpan">autobahn.</span>Registration
            <span class="apidocSignatureSpan">(procedure, endpoint, options, session, id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.Registration.prototype">module autobahn.Registration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Registration.prototype.unregister">
            function <span class="apidocSignatureSpan">autobahn.Registration.prototype.</span>unregister
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.Session">module autobahn.Session</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.Session">
            function <span class="apidocSignatureSpan">autobahn.</span>Session
            <span class="apidocSignatureSpan">(socket, defer, onchallenge)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.Session.prototype">module autobahn.Session.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.call">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>call
            <span class="apidocSignatureSpan">(procedure, args, kwargs, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.join">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>join
            <span class="apidocSignatureSpan">(realm, authmethods, authid, authextra)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.leave">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>leave
            <span class="apidocSignatureSpan">(reason, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.log">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.prefix">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>prefix
            <span class="apidocSignatureSpan">(prefix, uri)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.publish">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>publish
            <span class="apidocSignatureSpan">(topic, args, kwargs, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.register">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>register
            <span class="apidocSignatureSpan">(procedure, endpoint, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.resolve">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>resolve
            <span class="apidocSignatureSpan">(curie)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.subscribe">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(topic, handler, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.unregister">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>unregister
            <span class="apidocSignatureSpan">(registration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Session.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">(subscription)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.Subscription">module autobahn.Subscription</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Subscription.Subscription">
            function <span class="apidocSignatureSpan">autobahn.</span>Subscription
            <span class="apidocSignatureSpan">(topic, handler, options, session, id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.Subscription.prototype">module autobahn.Subscription.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.Subscription.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">autobahn.Subscription.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.auth_cra">module autobahn.auth_cra</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.auth_cra.derive_key">
            function <span class="apidocSignatureSpan">autobahn.auth_cra.</span>derive_key
            <span class="apidocSignatureSpan">(secret, salt, iterations, keylen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.auth_cra.sign">
            function <span class="apidocSignatureSpan">autobahn.auth_cra.</span>sign
            <span class="apidocSignatureSpan">(key, challenge)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.autobahn">module autobahn.autobahn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.Connection">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Connection
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.Error">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Error
            <span class="apidocSignatureSpan">(error, args, kwargs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.Event">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Event
            <span class="apidocSignatureSpan">(publication, topic, publisher, publisher_authid, publisher_authrole)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.Invocation">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Invocation
            <span class="apidocSignatureSpan">(procedure, progress, caller, caller_authid, caller_authrole)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.Publication">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Publication
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.Registration">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Registration
            <span class="apidocSignatureSpan">(procedure, endpoint, options, session, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.Result">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Result
            <span class="apidocSignatureSpan">(args, kwargs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.Session">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Session
            <span class="apidocSignatureSpan">(socket, defer, onchallenge)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.Subscription">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Subscription
            <span class="apidocSignatureSpan">(topic, handler, options, session, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.auth_persona">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>auth_persona
            <span class="apidocSignatureSpan">(session, user, extra)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.autobahn.when">
            function <span class="apidocSignatureSpan">autobahn.autobahn.</span>when
            <span class="apidocSignatureSpan">(x, onFulfilled, onRejected, onProgress)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.autobahn.</span>auth_cra</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.autobahn.</span>cbor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.autobahn.</span>log</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.autobahn.</span>msgpack</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.autobahn.</span>serializer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.autobahn.</span>transports</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.autobahn.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">autobahn.autobahn.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.cbor">module autobahn.cbor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.Commented">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>Commented
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.Decoder">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>Decoder
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.Diagnose">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>Diagnose
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.Encoder">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>Encoder
            <span class="apidocSignatureSpan">(Encoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.Simple">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>Simple
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.Tagged">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>Tagged
            <span class="apidocSignatureSpan">(tag, value, err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.comment">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>comment
            <span class="apidocSignatureSpan">(input, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.decode">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>decode
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.decodeAll">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>decodeAll
            <span class="apidocSignatureSpan">(input, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.decodeAllSync">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>decodeAllSync
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.decodeFirst">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>decodeFirst
            <span class="apidocSignatureSpan">(input, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.decodeFirstSync">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>decodeFirstSync
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.diagnose">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>diagnose
            <span class="apidocSignatureSpan">(input, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.encode">
            function <span class="apidocSignatureSpan">autobahn.cbor.</span>encode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.cbor.</span>leveldb</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.cbor.leveldb">module autobahn.cbor.leveldb</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">autobahn.cbor.leveldb.</span>buffer</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.leveldb.decode">
            function <span class="apidocSignatureSpan">autobahn.cbor.leveldb.</span>decode
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.cbor.leveldb.encode">
            function <span class="apidocSignatureSpan">autobahn.cbor.leveldb.</span>encode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">autobahn.cbor.leveldb.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.connection">module autobahn.connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.connection.Connection">
            function <span class="apidocSignatureSpan">autobahn.connection.</span>Connection
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.log">module autobahn.log</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.log.debug">
            function <span class="apidocSignatureSpan">autobahn.log.</span>debug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.log.warn">
            function <span class="apidocSignatureSpan">autobahn.log.</span>warn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.longpoll">module autobahn.longpoll</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.longpoll.Factory">
            function <span class="apidocSignatureSpan">autobahn.longpoll.</span>Factory
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.msgpack">module autobahn.msgpack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>Decoder
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Encoder">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>Encoder
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createCodec">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createCodec
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createDecodeStream">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createDecodeStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createEncodeStream">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createEncodeStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.decode">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>decode
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.encode">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>encode
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">autobahn.msgpack.</span>codec</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.msgpack.Decoder">module autobahn.msgpack.Decoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder.Decoder">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>Decoder
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.msgpack.Decoder.prototype">module autobahn.msgpack.Decoder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder.prototype.decode">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>decode
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder.prototype.emit">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>emit
            <span class="apidocSignatureSpan">(type, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder.prototype.end">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder.prototype.off">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>off
            <span class="apidocSignatureSpan">(type, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder.prototype.on">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>on
            <span class="apidocSignatureSpan">(type, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder.prototype.once">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>once
            <span class="apidocSignatureSpan">(type, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Decoder.prototype.push">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>push
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.msgpack.Encoder">module autobahn.msgpack.Encoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Encoder.Encoder">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>Encoder
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.msgpack.Encoder.prototype">module autobahn.msgpack.Encoder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Encoder.prototype.emit">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>emit
            <span class="apidocSignatureSpan">(type, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Encoder.prototype.encode">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>encode
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Encoder.prototype.end">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Encoder.prototype.off">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>off
            <span class="apidocSignatureSpan">(type, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Encoder.prototype.on">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>on
            <span class="apidocSignatureSpan">(type, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.Encoder.prototype.once">
            function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>once
            <span class="apidocSignatureSpan">(type, func)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.msgpack.createDecodeStream">module autobahn.msgpack.createDecodeStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createDecodeStream.createDecodeStream">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createDecodeStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createDecodeStream.super_">
            function <span class="apidocSignatureSpan">autobahn.msgpack.createDecodeStream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.msgpack.createDecodeStream.prototype">module autobahn.msgpack.createDecodeStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createDecodeStream.prototype._transform">
            function <span class="apidocSignatureSpan">autobahn.msgpack.createDecodeStream.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.msgpack.createEncodeStream">module autobahn.msgpack.createEncodeStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createEncodeStream.createEncodeStream">
            function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createEncodeStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createEncodeStream.super_">
            function <span class="apidocSignatureSpan">autobahn.msgpack.createEncodeStream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.msgpack.createEncodeStream.prototype">module autobahn.msgpack.createEncodeStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createEncodeStream.prototype._flush">
            function <span class="apidocSignatureSpan">autobahn.msgpack.createEncodeStream.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.msgpack.createEncodeStream.prototype._transform">
            function <span class="apidocSignatureSpan">autobahn.msgpack.createEncodeStream.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.persona">module autobahn.persona</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.persona.auth">
            function <span class="apidocSignatureSpan">autobahn.persona.</span>auth
            <span class="apidocSignatureSpan">(session, user, extra)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.rawsocket">module autobahn.rawsocket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.rawsocket.Factory">
            function <span class="apidocSignatureSpan">autobahn.rawsocket.</span>Factory
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.rawsocket.Protocol">
            function <span class="apidocSignatureSpan">autobahn.rawsocket.</span>Protocol
            <span class="apidocSignatureSpan">(stream, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.rawsocket.ProtocolError">
            function <span class="apidocSignatureSpan">autobahn.rawsocket.</span>ProtocolError
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.serializer">module autobahn.serializer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.CBORSerializer">
            function <span class="apidocSignatureSpan">autobahn.serializer.</span>CBORSerializer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.JSONSerializer">
            function <span class="apidocSignatureSpan">autobahn.serializer.</span>JSONSerializer
            <span class="apidocSignatureSpan">(replacer, reviver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.MsgpackSerializer">
            function <span class="apidocSignatureSpan">autobahn.serializer.</span>MsgpackSerializer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.serializer.CBORSerializer">module autobahn.serializer.CBORSerializer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.CBORSerializer.CBORSerializer">
            function <span class="apidocSignatureSpan">autobahn.serializer.</span>CBORSerializer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.serializer.CBORSerializer.prototype">module autobahn.serializer.CBORSerializer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.CBORSerializer.prototype.serialize">
            function <span class="apidocSignatureSpan">autobahn.serializer.CBORSerializer.prototype.</span>serialize
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.CBORSerializer.prototype.unserialize">
            function <span class="apidocSignatureSpan">autobahn.serializer.CBORSerializer.prototype.</span>unserialize
            <span class="apidocSignatureSpan">(payload)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.serializer.JSONSerializer">module autobahn.serializer.JSONSerializer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.JSONSerializer.JSONSerializer">
            function <span class="apidocSignatureSpan">autobahn.serializer.</span>JSONSerializer
            <span class="apidocSignatureSpan">(replacer, reviver)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.serializer.JSONSerializer.prototype">module autobahn.serializer.JSONSerializer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.JSONSerializer.prototype.serialize">
            function <span class="apidocSignatureSpan">autobahn.serializer.JSONSerializer.prototype.</span>serialize
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.JSONSerializer.prototype.unserialize">
            function <span class="apidocSignatureSpan">autobahn.serializer.JSONSerializer.prototype.</span>unserialize
            <span class="apidocSignatureSpan">(payload)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.serializer.MsgpackSerializer">module autobahn.serializer.MsgpackSerializer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.MsgpackSerializer.MsgpackSerializer">
            function <span class="apidocSignatureSpan">autobahn.serializer.</span>MsgpackSerializer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.serializer.MsgpackSerializer.prototype">module autobahn.serializer.MsgpackSerializer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.MsgpackSerializer.prototype.registerExtType">
            function <span class="apidocSignatureSpan">autobahn.serializer.MsgpackSerializer.prototype.</span>registerExtType
            <span class="apidocSignatureSpan">(code, type, packer, unpacker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.MsgpackSerializer.prototype.serialize">
            function <span class="apidocSignatureSpan">autobahn.serializer.MsgpackSerializer.prototype.</span>serialize
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.serializer.MsgpackSerializer.prototype.unserialize">
            function <span class="apidocSignatureSpan">autobahn.serializer.MsgpackSerializer.prototype.</span>unserialize
            <span class="apidocSignatureSpan">(payload)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.session">module autobahn.session</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.session.Error">
            function <span class="apidocSignatureSpan">autobahn.session.</span>Error
            <span class="apidocSignatureSpan">(error, args, kwargs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.session.Event">
            function <span class="apidocSignatureSpan">autobahn.session.</span>Event
            <span class="apidocSignatureSpan">(publication, topic, publisher, publisher_authid, publisher_authrole)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.session.Invocation">
            function <span class="apidocSignatureSpan">autobahn.session.</span>Invocation
            <span class="apidocSignatureSpan">(procedure, progress, caller, caller_authid, caller_authrole)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.session.Publication">
            function <span class="apidocSignatureSpan">autobahn.session.</span>Publication
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.session.Registration">
            function <span class="apidocSignatureSpan">autobahn.session.</span>Registration
            <span class="apidocSignatureSpan">(procedure, endpoint, options, session, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.session.Result">
            function <span class="apidocSignatureSpan">autobahn.session.</span>Result
            <span class="apidocSignatureSpan">(args, kwargs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.session.Session">
            function <span class="apidocSignatureSpan">autobahn.session.</span>Session
            <span class="apidocSignatureSpan">(socket, defer, onchallenge)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.session.Subscription">
            function <span class="apidocSignatureSpan">autobahn.session.</span>Subscription
            <span class="apidocSignatureSpan">(topic, handler, options, session, id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.util">module autobahn.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.util.assert">
            function <span class="apidocSignatureSpan">autobahn.util.</span>assert
            <span class="apidocSignatureSpan">(cond, text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.util.defaults">
            function <span class="apidocSignatureSpan">autobahn.util.</span>defaults
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.util.http_post">
            function <span class="apidocSignatureSpan">autobahn.util.</span>http_post
            <span class="apidocSignatureSpan">(url, data, timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.util.rand_normal">
            function <span class="apidocSignatureSpan">autobahn.util.</span>rand_normal
            <span class="apidocSignatureSpan">(mean, sd)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.websocket">module autobahn.websocket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.websocket.Factory">
            function <span class="apidocSignatureSpan">autobahn.websocket.</span>Factory
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.when">module autobahn.when</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.when">
            function <span class="apidocSignatureSpan">autobahn.</span>when
            <span class="apidocSignatureSpan">(x, onFulfilled, onRejected, onProgress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise">
            function <span class="apidocSignatureSpan">autobahn.when.</span>Promise
            <span class="apidocSignatureSpan">(resolver, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.TimeoutError">
            function <span class="apidocSignatureSpan">autobahn.when.</span>TimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.all">
            function <span class="apidocSignatureSpan">autobahn.when.</span>all
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.any">
            function <span class="apidocSignatureSpan">autobahn.when.</span>any
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.attempt">
            function <span class="apidocSignatureSpan">autobahn.when.</span>attempt
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.defer">
            function <span class="apidocSignatureSpan">autobahn.when.</span>defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.filter">
            function <span class="apidocSignatureSpan">autobahn.when.</span>filter
            <span class="apidocSignatureSpan">(promises, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.isPromiseLike">
            function <span class="apidocSignatureSpan">autobahn.when.</span>isPromiseLike
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.iterate">
            function <span class="apidocSignatureSpan">autobahn.when.</span>iterate
            <span class="apidocSignatureSpan">(f, condition, handler, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.join">
            function <span class="apidocSignatureSpan">autobahn.when.</span>join
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.lift">
            function <span class="apidocSignatureSpan">autobahn.when.</span>lift
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.map">
            function <span class="apidocSignatureSpan">autobahn.when.</span>map
            <span class="apidocSignatureSpan">(promises, mapFunc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.promise">
            function <span class="apidocSignatureSpan">autobahn.when.</span>promise
            <span class="apidocSignatureSpan">(resolver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.race">
            function <span class="apidocSignatureSpan">autobahn.when.</span>race
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.reduce">
            function <span class="apidocSignatureSpan">autobahn.when.</span>reduce
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.reduceRight">
            function <span class="apidocSignatureSpan">autobahn.when.</span>reduceRight
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.reject">
            function <span class="apidocSignatureSpan">autobahn.when.</span>reject
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.resolve">
            function <span class="apidocSignatureSpan">autobahn.when.</span>resolve
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.settle">
            function <span class="apidocSignatureSpan">autobahn.when.</span>settle
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.some">
            function <span class="apidocSignatureSpan">autobahn.when.</span>some
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.try">
            function <span class="apidocSignatureSpan">autobahn.when.</span>try
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.unfold">
            function <span class="apidocSignatureSpan">autobahn.when.</span>unfold
            <span class="apidocSignatureSpan">(unspool, condition, handler, x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.when.Promise">module autobahn.when.Promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.Promise">
            function <span class="apidocSignatureSpan">autobahn.when.</span>Promise
            <span class="apidocSignatureSpan">(resolver, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise._defer">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>_defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise._handler">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>_handler
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise._traverse">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>_traverse
            <span class="apidocSignatureSpan">(f, promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise._visitRemaining">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>_visitRemaining
            <span class="apidocSignatureSpan">(promises, start, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.all">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>all
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.any">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>any
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.createContext">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>createContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.enterContext">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>enterContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.exitContext">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>exitContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.filter">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>filter
            <span class="apidocSignatureSpan">(promises, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.iterate">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>iterate
            <span class="apidocSignatureSpan">(f, condition, handler, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.map">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>map
            <span class="apidocSignatureSpan">(promises, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.never">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>never
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.onFatalRejection">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>onFatalRejection
            <span class="apidocSignatureSpan">(rejection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.onPotentiallyUnhandledRejection">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>onPotentiallyUnhandledRejection
            <span class="apidocSignatureSpan">(rejection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.onPotentiallyUnhandledRejectionHandled">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>onPotentiallyUnhandledRejectionHandled
            <span class="apidocSignatureSpan">(rejection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.race">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>race
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.reduce">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>reduce
            <span class="apidocSignatureSpan">(promises, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.reduceRight">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>reduceRight
            <span class="apidocSignatureSpan">(promises, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.reject">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>reject
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.resolve">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>resolve
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.settle">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>settle
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.some">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>some
            <span class="apidocSignatureSpan">(promises, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.unfold">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>unfold
            <span class="apidocSignatureSpan">(unspool, condition, handler, x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.when.Promise.prototype">module autobahn.when.Promise.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype._beget">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>_beget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.catch">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>catch
            <span class="apidocSignatureSpan">(onRejected)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.delay">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>delay
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.done">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>done
            <span class="apidocSignatureSpan">(onResult, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.else">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>else
            <span class="apidocSignatureSpan">(defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.ensure">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>ensure
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.finally">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>finally
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.fold">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>fold
            <span class="apidocSignatureSpan">(f, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.inspect">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.orElse">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>orElse
            <span class="apidocSignatureSpan">(defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.otherwise">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>otherwise
            <span class="apidocSignatureSpan">(onRejected)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.progress">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>progress
            <span class="apidocSignatureSpan">(onProgress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.spread">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>spread
            <span class="apidocSignatureSpan">(onFulfilled)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.tap">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>tap
            <span class="apidocSignatureSpan">(onFulfilledSideEffect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.then">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>then
            <span class="apidocSignatureSpan">(onFulfilled, onRejected, onProgress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.timeout">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>timeout
            <span class="apidocSignatureSpan">(ms, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.with">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>with
            <span class="apidocSignatureSpan">(receiver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.withThis">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>withThis
            <span class="apidocSignatureSpan">(receiver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.Promise.prototype.yield">
            function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>yield
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.when.TimeoutError">module autobahn.when.TimeoutError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.TimeoutError.TimeoutError">
            function <span class="apidocSignatureSpan">autobahn.when.</span>TimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.autobahn.when.TimeoutError.prototype">module autobahn.when.TimeoutError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.autobahn.when.TimeoutError.prototype.constructor">
            function <span class="apidocSignatureSpan">autobahn.when.TimeoutError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn" id="apidoc.module.autobahn">module autobahn</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.Connection" id="apidoc.element.autobahn.Connection">
        function <span class="apidocSignatureSpan">autobahn.</span>Connection
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection = function (options) {

   var self = this;

   self._options = options;


   // Deferred factory
   //
   if (options &#x26;&#x26; options.use_es6_promises) {

      if (&#x27;Promise&#x27; in global) {
         // ES6-based deferred factory
         //
         self._defer = function () {
            var deferred = {};

            deferred.promise = new Promise(function (resolve, reject) {
               deferred.resolve = resolve;
               deferred.reject = reject;
            });

            return deferred;
         };
      } else {

         log.debug(&#x22;Warning: ES6 promises requested, but not found! Falling back to whenjs.&#x22;);

         // whenjs-based deferred factory
         //
         self._defer = when.defer;
      }

   } else if (options &#x26;&#x26; options.use_deferred) {

      // use explicit deferred factory, e.g. jQuery.Deferred or Q.defer
      //
      self._defer = options.use_deferred;

   } else {

      // whenjs-based deferred factory
      //
      self._defer = when.defer;
   }


   // WAMP transport
   //
   // backward compatiblity
   if (!self._options.transports) {
      self._options.transports = [
         {
            type: &#x27;websocket&#x27;,
            url: self._options.url
         }
      ];
   }
   self._transport_factories = [];
   self._init_transport_factories();


   // WAMP session
   //
   self._session = null;
   self._session_close_reason = null;
   self._session_close_message = null;

   // automatic reconnection configuration
   //

   // enable automatic reconnect if host is unreachable
   if (self._options.retry_if_unreachable !== undefined) {
      self._retry_if_unreachable = self._options.retry_if_unreachable;
   } else {
      self._retry_if_unreachable = true;
   }

   // maximum number of reconnection attempts
   self._max_retries = typeof self._options.max_retries !== &#x27;undefined&#x27; ?  self._options.max_retries : 15;

   // initial retry delay in seconds
   self._initial_retry_delay = self._options.initial_retry_delay || 1.5;

   // maximum seconds between reconnection attempts
   self._max_retry_delay = self._options.max_retry_delay || 300;

   // the growth factor applied to the retry delay on each retry cycle
   self._retry_delay_growth = self._options.retry_delay_growth || 1.5;

   // the SD of a Gaussian to jitter the delay on each retry cycle
   // as a fraction of the mean
   self._retry_delay_jitter = self._options.retry_delay_jitter || 0.1;

   // reconnection tracking
   //

   // total number of successful connections
   self._connect_successes = 0;

   // controls if we should try to reconnect
   self._retry = false;

   // current number of reconnect cycles we went through
   self._retry_count = 0;

   // the current retry delay
   self._retry_delay = self._initial_retry_delay;

   // flag indicating if we are currently in a reconnect cycle
   self._is_retrying = false;

   // when retrying, this is the timer object returned from window.setTimeout()
   self._retry_timer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Callee (offers a remote procedure)

**The code runs unaltered in the browser or Node.js!**

```javascript
var autobahn = require(&#x27;autobahn&#x27;);

var connection = new autobahn.<span class="apidocCodeKeywordSpan">Connection</span>({url: &#x27;ws://127.0.0.1:9000/&#x27;, realm
: &#x27;realm1&#x27;});

connection.onopen = function (session) {

// 1) subscribe to a topic
function onevent(args) {
   console.log(&#x22;Event:&#x22;, args[0]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Error" id="apidoc.element.autobahn.Error">
        function <span class="apidocSignatureSpan">autobahn.</span>Error
        <span class="apidocSignatureSpan">(error, args, kwargs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error = function (error, args, kwargs) {

   var self = this;

   self.error = error;
   self.args = args || [];
   self.kwargs = kwargs || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
logging this in the caller will come out something like

    wamp.error.runtime_error [&#x22;this is just an error&#x22;, &#x22;with an array of arguments&#x22;] Object {}

When defining an `autobahn.Error` object, all three properties can be defined. I.e. doing

``` js
throw new autobahn.<span class="apidocCodeKeywordSpan">Error</span>(&#x27;com.myapp.error&#x27;, [&#x27;this is a more complex error
&#x27;], {a: 23, b: 9});
```

and logging this in the caller will lead to something like

    com.myapp.error [&#x27;this is a more complex error&#x27;] Object {a: 23, b: 9}

Complete Examples:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Event" id="apidoc.element.autobahn.Event">
        function <span class="apidocSignatureSpan">autobahn.</span>Event
        <span class="apidocSignatureSpan">(publication, topic, publisher, publisher_authid, publisher_authrole)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Event = function (publication, topic, publisher, publisher_authid, publisher_authrole) {

   var self = this;

   self.publication = publication;
   self.topic = topic;
   self.publisher = publisher;
   self.publisher_authid = publisher_authid;
   self.publisher_authrole = publisher_authrole;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Invocation" id="apidoc.element.autobahn.Invocation">
        function <span class="apidocSignatureSpan">autobahn.</span>Invocation
        <span class="apidocSignatureSpan">(procedure, progress, caller, caller_authid, caller_authrole)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Invocation = function (procedure, progress, caller, caller_authid, caller_authrole) {

   var self = this;

   self.procedure = procedure;
   self.progress = progress;
   self.caller = caller;
   self.caller_authid = caller_authid;
   self.caller_authrole = caller_authrole;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Publication" id="apidoc.element.autobahn.Publication">
        function <span class="apidocSignatureSpan">autobahn.</span>Publication
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Publication = function (id) {

   var self = this;
   self.id = id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Registration" id="apidoc.element.autobahn.Registration">
        function <span class="apidocSignatureSpan">autobahn.</span>Registration
        <span class="apidocSignatureSpan">(procedure, endpoint, options, session, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Registration = function (procedure, endpoint, options, session, id) {

   var self = this;

   self.procedure = procedure;
   self.endpoint = endpoint;
   self.options = options || {};
   self.session = session;
   self.id = id;

   self.active = true;

   // this will fire when the endpoint is unregistered
   self._on_unregister = session._defer();

   if (self._on_unregister.promise.then) {
      // whenjs has the actual user promise in an attribute
      self.on_unregister = self._on_unregister.promise;
   } else {
      self.on_unregister = self._on_unregister;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Result" id="apidoc.element.autobahn.Result">
        function <span class="apidocSignatureSpan">autobahn.</span>Result
        <span class="apidocSignatureSpan">(args, kwargs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Result = function (args, kwargs) {

   var self = this;

   self.args = args || [];
   self.kwargs = kwargs || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   connection.onopen = function (session) {

test.log(&#x27;Connected&#x27;);

function add_complex(args, kwargs) {
   test.log(&#x22;add_complex()&#x22;, args, kwargs);
   return new autobahn.<span class="apidocCodeKeywordSpan">Result</span>([], {c: args[0] + args[2], ci: args[1] + args[3]});
}

function split_name(args) {
   test.log(&#x22;split_name()&#x22;, args);
   return new autobahn.Result(args[0].split(&#x22; &#x22;));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session" id="apidoc.element.autobahn.Session">
        function <span class="apidocSignatureSpan">autobahn.</span>Session
        <span class="apidocSignatureSpan">(socket, defer, onchallenge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Session = function (socket, defer, onchallenge) {

   var self = this;

   // the transport connection (WebSocket object)
   self._socket = socket;

   // the Deferred factory to use
   self._defer = defer;

   // the WAMP authentication challenge handler
   self._onchallenge = onchallenge;

   // the WAMP session ID
   self._id = null;

   // the WAMP realm joined
   self._realm = null;

   // the WAMP features in use
   self._features = null;

   // closing state
   self._goodbye_sent = false;
   self._transport_is_closing = false;

   // outstanding requests;
   self._publish_reqs = {};
   self._subscribe_reqs = {};
   self._unsubscribe_reqs = {};
   self._call_reqs = {};
   self._register_reqs = {};
   self._unregister_reqs = {};

   // subscriptions in place;
   self._subscriptions = {};

   // registrations in place;
   self._registrations = {};

   // incoming invocations;
   self._invocations = {};

   // prefix shortcuts for URIs
   self._prefixes = {};

   // the defaults for &#x27;disclose_me&#x27;
   self._caller_disclose_me = false;
   self._publisher_disclose_me = false;

   self._send_wamp = function (msg) {
      log.debug(msg);
      // forward WAMP message to be sent to WAMP transport
      self._socket.send(msg);
   };


   self._protocol_violation = function (reason) {
      log.warn(&#x22;failing transport due to protocol violation: &#x22; + reason);
      self._socket.close(1002, &#x22;protocol violation: &#x22; + reason);
   };

   self._MESSAGE_MAP = {};
   self._MESSAGE_MAP[MSG_TYPE.ERROR] = {};


   self._process_SUBSCRIBED = function (msg) {
      //
      // process SUBSCRIBED reply to SUBSCRIBE
      //
      var request = msg[1];
      var subscription = msg[2];

      if (request in self._subscribe_reqs) {

         var r = self._subscribe_reqs[request];

         var d = r[0];
         var topic = r[1];
         var handler = r[2];
         var options = r[3];

         if (!(subscription in self._subscriptions)) {
            self._subscriptions[subscription] = [];
         }
         var sub = new Subscription(topic, handler, options, self, subscription);
         self._subscriptions[subscription].push(sub);

         d.resolve(sub);

         delete self._subscribe_reqs[request];

      } else {
         self._protocol_violation(&#x22;SUBSCRIBED received for non-pending request ID &#x22; + request);
      }
   };
   self._MESSAGE_MAP[MSG_TYPE.SUBSCRIBED] = self._process_SUBSCRIBED;


   self._process_SUBSCRIBE_ERROR = function (msg) {
      //
      // process ERROR reply to SUBSCRIBE
      //
      var request = msg[2];
      if (request in self._subscribe_reqs) {

         var details = msg[3];
         var error = new Error(msg[4], msg[5], msg[6]);

         var r = self._subscribe_reqs[request];

         var d = r[0];

         d.reject(error);

         delete self._subscribe_reqs[request];

      } else {
         self._protocol_violation(&#x22;SUBSCRIBE-ERROR received for non-pending request ID &#x22; + request);
      }
   };
   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.SUBSCRIBE] = self._process_SUBSCRIBE_ERROR;


   self._process_UNSUBSCRIBED = function (msg) {
      //
      // process UNSUBSCRIBED reply to UNSUBSCRIBE
      //
      var request = msg[1];

      if (request in self._unsubscribe_reqs) {

         var r = self._unsubscribe_reqs[request];

         var d = r[0];
         var subscription_id = r[1];

         if (subscription_id in self._subscriptions) {
            var subs = self._subscriptions[subscription_id];
            // the following should actually be NOP, since UNSUBSCRIBE was
            // only sent when subs got empty
            for (var i = 0; i &#x3c; subs.length; ++i) {
               subs[i].active = false;
               subs[i].on_unsubscribe.resolve();
            }
            delete self._subscriptions[subscription_id];
         }

         d.resolve(true);

         delete self._unsubscribe_reqs[request];

      } else {

         if (request === 0) {

            // router actively revoked our subscription
            //
            var details = msg[2];
            var subscription_id = details.sub ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   };
   self.onclose(&#x22;unsupported&#x22;, details);
}
return;
      }

      // create a new WAMP session using the WebSocket connection as transport
      self._session = new session.<span class="apidocCodeKeywordSpan">Session</span>(self._transport, self._defer, self._options
.onchallenge);
      self._session_close_reason = null;
      self._session_close_message = null;

      self._transport.onopen = function () {

// reset auto-reconnect timer and tracking
self._autoreconnect_reset();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Subscription" id="apidoc.element.autobahn.Subscription">
        function <span class="apidocSignatureSpan">autobahn.</span>Subscription
        <span class="apidocSignatureSpan">(topic, handler, options, session, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Subscription = function (topic, handler, options, session, id) {

   var self = this;

   self.topic = topic;
   self.handler = handler;
   self.options = options || {};
   self.session = session;
   self.id = id;

   self.active = true;

   // this will fire when the handler is unsubscribed
   self._on_unsubscribe = session._defer();

   if (self._on_unsubscribe.promise.then) {
      // whenjs has the actual user promise in an attribute
      self.on_unsubscribe = self._on_unsubscribe.promise;
   } else {
      self.on_unsubscribe = self._on_unsubscribe;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.auth_persona" id="apidoc.element.autobahn.auth_persona">
        function <span class="apidocSignatureSpan">autobahn.</span>auth_persona
        <span class="apidocSignatureSpan">(session, user, extra)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auth(session, user, extra) {

   // Persona Issues:
   //
   // Chrome: https://github.com/mozilla/persona/issues/4083
   // IE11: https://groups.google.com/forum/#!topic/mozilla.dev.identity/keEkVpvfLA8

   var d = session.defer();

   navigator.id.watch({
      loggedInUser: user,
      onlogin: function (assertion) {
         // A user has logged in! Here you need to:
         // 1. Send the assertion to your backend for verification and to create a session.
         // 2. Update your UI.
         d.resolve(assertion);
      },
      onlogout: function() {
         // A user has logged out! Here you need to:
         // Tear down the user&#x27;s session by redirecting the user or making a call to your backend.
         // Also, make sure loggedInUser will get set to null on the next page load.
         // (That&#x27;s a literal JavaScript null. Not false, 0, or undefined. null.)
         session.leave(&#x22;wamp.close.logout&#x22;);
      }
   });

   if (d.promise.then) {
      // whenjs has the actual user promise in an attribute
      return d.promise;
   } else {
      return d;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder" id="apidoc.element.autobahn.msgpack.Decoder">
        function <span class="apidocSignatureSpan">autobahn.</span>msgpack.Decoder
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decoder(options) {
  if (!(this instanceof Decoder)) return new Decoder(options);
  DecodeBuffer.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Encoder" id="apidoc.element.autobahn.msgpack.Encoder">
        function <span class="apidocSignatureSpan">autobahn.</span>msgpack.Encoder
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Encoder(options) {
  if (!(this instanceof Encoder)) return new Encoder(options);
  EncodeBuffer.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createDecodeStream" id="apidoc.element.autobahn.msgpack.createDecodeStream">
        function <span class="apidocSignatureSpan">autobahn.</span>msgpack.createDecodeStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DecodeStream(options) {
  if (!(this instanceof DecodeStream)) return new DecodeStream(options);
  if (options) {
    options.objectMode = true;
  } else {
    options = DEFAULT_OPTIONS;
  }
  Transform.call(this, options);
  var stream = this;
  var decoder = this.decoder = new DecodeBuffer(options);
  decoder.push = function(chunk) {
    stream.push(chunk);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createEncodeStream" id="apidoc.element.autobahn.msgpack.createEncodeStream">
        function <span class="apidocSignatureSpan">autobahn.</span>msgpack.createEncodeStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EncodeStream(options) {
  if (!(this instanceof EncodeStream)) return new EncodeStream(options);
  if (options) {
    options.objectMode = true;
  } else {
    options = DEFAULT_OPTIONS;
  }
  Transform.call(this, options);

  var stream = this;
  var encoder = this.encoder = new EncodeBuffer(options);
  encoder.push = function(chunk) {
    stream.push(chunk);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.serializer.CBORSerializer" id="apidoc.element.autobahn.serializer.CBORSerializer">
        function <span class="apidocSignatureSpan">autobahn.</span>serializer.CBORSerializer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CBORSerializer() {
   this.SERIALIZER_ID = &#x27;cbor&#x27;;
   this.BINARY = true;

   // CBOR encoder does not need anything special here
   this.newid = newid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.testCBORSerialization = function (testcase) {

testcase.expect(1);

var test = new testutil.Testlog(&#x22;test/test_serialization_cbor.txt&#x22;);

var ser = new autobahn.<span class="apidocCodeKeywordSpan">serializer.CBORSerializer</span>();

var config = {
   url: testutil.config.url,
   realm: testutil.config.realm,
   serializers: [ser]
};
var connection = new autobahn.Connection(config);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.serializer.JSONSerializer" id="apidoc.element.autobahn.serializer.JSONSerializer">
        function <span class="apidocSignatureSpan">autobahn.</span>serializer.JSONSerializer
        <span class="apidocSignatureSpan">(replacer, reviver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONSerializer(replacer, reviver) {
   this.replacer = replacer;
   this.reviver = reviver;
   this.SERIALIZER_ID = &#x27;json&#x27;;
   this.BINARY = false;

   // JSON encoder does not need anything special here
   this.newid = newid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.testJSONSerialization = function (testcase) {

testcase.expect(1);

var test = new testutil.Testlog(&#x22;test/test_serialization_json.txt&#x22;);

var ser = new autobahn.<span class="apidocCodeKeywordSpan">serializer.JSONSerializer</span>();

var config = {
   url: testutil.config.url,
   realm: testutil.config.realm,
   serializers: [ser]
};
var connection = new autobahn.Connection(config);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.serializer.MsgpackSerializer" id="apidoc.element.autobahn.serializer.MsgpackSerializer">
        function <span class="apidocSignatureSpan">autobahn.</span>serializer.MsgpackSerializer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MsgpackSerializer() {
   this.SERIALIZER_ID = &#x27;msgpack&#x27;;
   this.BINARY = true;
   this.codec = msgpack.createCodec();

   // msgpack: Uint64BE ensures that ID is encoded as int instead of double
   this.newid = function () { return new Uint64BE(newid()); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         type: &#x27;rawsocket&#x27;,
         host: &#x27;127.0.0.1&#x27;,
         port: 8080
      }
   ],
   // FIXME - serializer is ignored! sth wrong
   serializers: [
      new autobahn.<span class="apidocCodeKeywordSpan">serializer.MsgpackSerializer</span>()
   ],
   protocols: [&#x27;wamp.2.msgpack&#x27;]
};

var dl = testutil.connect_n(N, connection_config);

autobahn.when.all(dl).then(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when" id="apidoc.element.autobahn.when">
        function <span class="apidocSignatureSpan">autobahn.</span>when
        <span class="apidocSignatureSpan">(x, onFulfilled, onRejected, onProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length &#x3c; 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise" id="apidoc.element.autobahn.when.Promise">
        function <span class="apidocSignatureSpan">autobahn.</span>when.Promise
        <span class="apidocSignatureSpan">(resolver, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.TimeoutError" id="apidoc.element.autobahn.when.TimeoutError">
        function <span class="apidocSignatureSpan">autobahn.</span>when.TimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === &#x27;function&#x27;) {
			Error.captureStackTrace(this, TimeoutError);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.Connection" id="apidoc.module.autobahn.Connection">module autobahn.Connection</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.Connection.Connection" id="apidoc.element.autobahn.Connection.Connection">
        function <span class="apidocSignatureSpan">autobahn.</span>Connection
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection = function (options) {

   var self = this;

   self._options = options;


   // Deferred factory
   //
   if (options &#x26;&#x26; options.use_es6_promises) {

      if (&#x27;Promise&#x27; in global) {
         // ES6-based deferred factory
         //
         self._defer = function () {
            var deferred = {};

            deferred.promise = new Promise(function (resolve, reject) {
               deferred.resolve = resolve;
               deferred.reject = reject;
            });

            return deferred;
         };
      } else {

         log.debug(&#x22;Warning: ES6 promises requested, but not found! Falling back to whenjs.&#x22;);

         // whenjs-based deferred factory
         //
         self._defer = when.defer;
      }

   } else if (options &#x26;&#x26; options.use_deferred) {

      // use explicit deferred factory, e.g. jQuery.Deferred or Q.defer
      //
      self._defer = options.use_deferred;

   } else {

      // whenjs-based deferred factory
      //
      self._defer = when.defer;
   }


   // WAMP transport
   //
   // backward compatiblity
   if (!self._options.transports) {
      self._options.transports = [
         {
            type: &#x27;websocket&#x27;,
            url: self._options.url
         }
      ];
   }
   self._transport_factories = [];
   self._init_transport_factories();


   // WAMP session
   //
   self._session = null;
   self._session_close_reason = null;
   self._session_close_message = null;

   // automatic reconnection configuration
   //

   // enable automatic reconnect if host is unreachable
   if (self._options.retry_if_unreachable !== undefined) {
      self._retry_if_unreachable = self._options.retry_if_unreachable;
   } else {
      self._retry_if_unreachable = true;
   }

   // maximum number of reconnection attempts
   self._max_retries = typeof self._options.max_retries !== &#x27;undefined&#x27; ?  self._options.max_retries : 15;

   // initial retry delay in seconds
   self._initial_retry_delay = self._options.initial_retry_delay || 1.5;

   // maximum seconds between reconnection attempts
   self._max_retry_delay = self._options.max_retry_delay || 300;

   // the growth factor applied to the retry delay on each retry cycle
   self._retry_delay_growth = self._options.retry_delay_growth || 1.5;

   // the SD of a Gaussian to jitter the delay on each retry cycle
   // as a fraction of the mean
   self._retry_delay_jitter = self._options.retry_delay_jitter || 0.1;

   // reconnection tracking
   //

   // total number of successful connections
   self._connect_successes = 0;

   // controls if we should try to reconnect
   self._retry = false;

   // current number of reconnect cycles we went through
   self._retry_count = 0;

   // the current retry delay
   self._retry_delay = self._initial_retry_delay;

   // flag indicating if we are currently in a reconnect cycle
   self._is_retrying = false;

   // when retrying, this is the timer object returned from window.setTimeout()
   self._retry_timer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Callee (offers a remote procedure)

**The code runs unaltered in the browser or Node.js!**

```javascript
var autobahn = require(&#x27;autobahn&#x27;);

var connection = new autobahn.<span class="apidocCodeKeywordSpan">Connection</span>({url: &#x27;ws://127.0.0.1:9000/&#x27;, realm
: &#x27;realm1&#x27;});

connection.onopen = function (session) {

// 1) subscribe to a topic
function onevent(args) {
   console.log(&#x22;Event:&#x22;, args[0]);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.Connection.prototype" id="apidoc.module.autobahn.Connection.prototype">module autobahn.Connection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.Connection.prototype._autoreconnect_advance" id="apidoc.element.autobahn.Connection.prototype._autoreconnect_advance">
        function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_autoreconnect_advance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_autoreconnect_advance = function () {

   var self = this;

   // jitter retry delay
   if (self._retry_delay_jitter) {
      self._retry_delay = util.rand_normal(self._retry_delay, self._retry_delay * self._retry_delay_jitter);
   }

   // cap the retry delay
   if (self._retry_delay &#x3e; self._max_retry_delay) {
      self._retry_delay = self._max_retry_delay;
   }

   // count number of retries
   self._retry_count += 1;

   var res;
   if (self._retry &#x26;&#x26; (self._max_retries === -1 || self._retry_count &#x3c;= self._max_retries)) {
      res = {
         count: self._retry_count,
         delay: self._retry_delay,
         will_retry: true
      };
   } else {
      res = {
         count: null,
         delay: null,
         will_retry: false
      }
   }

   // retry delay growth for next retry cycle
   if (self._retry_delay_growth) {
      self._retry_delay = self._retry_delay * self._retry_delay_growth;
   }

   return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (!evt.wasClean) {
   reason = &#x22;lost&#x22;;

} else {
   reason = &#x22;closed&#x22;;
}

var next_retry = self.<span class="apidocCodeKeywordSpan">_autoreconnect_advance</span>();

// fire app code handler
//
if (self.onclose) {
   var details = {
      reason: self._session_close_reason,
      message: self._session_close_message,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Connection.prototype._autoreconnect_reset" id="apidoc.element.autobahn.Connection.prototype._autoreconnect_reset">
        function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_autoreconnect_reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_autoreconnect_reset = function () {

   var self = this;

   self._autoreconnect_reset_timer();

   self._retry_count = 0;
   self._retry_delay = self._initial_retry_delay;
   self._is_retrying = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   var self = this;

   if (self._transport) {
throw &#x22;connection already open (or opening)&#x22;;
   }

   self.<span class="apidocCodeKeywordSpan">_autoreconnect_reset</span>();
   self._retry = true;

   function retry () {

// create a WAMP transport
try {
   self._transport = self._create_transport();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Connection.prototype._autoreconnect_reset_timer" id="apidoc.element.autobahn.Connection.prototype._autoreconnect_reset_timer">
        function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_autoreconnect_reset_timer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_autoreconnect_reset_timer = function () {

   var self = this;

   if (self._retry_timer) {
      clearTimeout(self._retry_timer);
   }
   self._retry_timer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


Connection.prototype._autoreconnect_reset = function () {

   var self = this;

   self.<span class="apidocCodeKeywordSpan">_autoreconnect_reset_timer</span>();

   self._retry_count = 0;
   self._retry_delay = self._initial_retry_delay;
   self._is_retrying = false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Connection.prototype._create_transport" id="apidoc.element.autobahn.Connection.prototype._create_transport">
        function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_create_transport
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_create_transport = function () {
   for (var i = 0; i &#x3c; this._transport_factories.length; ++i) {
      var transport_factory = this._transport_factories[i];
      log.debug(&#x22;trying to create WAMP transport of type: &#x22; + transport_factory.type);
      try {
         var transport = transport_factory.create();
         if (transport) {
            log.debug(&#x22;using WAMP transport type: &#x22; + transport_factory.type);
            return transport;
         }
      } catch (e) {
         // ignore
         log.warn(&#x22;could not create WAMP transport &#x27;&#x22; + transport_factory.type + &#x22;&#x27;: &#x22; + e);
      }
   }

   log.warn(&#x27;could not create any WAMP transport&#x27;);
   return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   self._autoreconnect_reset();
   self._retry = true;

   function retry () {

// create a WAMP transport
try {
   self._transport = self.<span class="apidocCodeKeywordSpan">_create_transport</span>();
} catch (e) {
   console.log(e);
}

if (!self._transport) {
   // failed to create a WAMP transport
   self._retry = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Connection.prototype._init_transport_factories" id="apidoc.element.autobahn.Connection.prototype._init_transport_factories">
        function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>_init_transport_factories
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_init_transport_factories = function () {
    // WAMP transport
    //
    var transports, transport_options, transport_factory, transport_factory_klass;

    util.assert(this._options.transports, &#x22;No transport.factory specified&#x22;);
    transports = this._options.transports;
    //if(typeof transports === &#x22;object&#x22;) {
    //    this._options.transports = [transports];
    //}
    for(var i = 0; i &#x3c; this._options.transports.length; ++i) {
        // cascading transports until we find one which works
        transport_options =  this._options.transports[i];

        if (!transport_options.url) {
            // defaulting to options.url if none is provided
            transport_options.url = this._options.url;
        }
        if (!transport_options.serializers) {
            transport_options.serializers = this._options.serializers;
        }
        if (!transport_options.protocols) {
            transport_options.protocols = this._options.protocols;
        }
        util.assert(transport_options.type, &#x22;No transport.type specified&#x22;);
        util.assert(typeof transport_options.type === &#x22;string&#x22;, &#x22;transport.type must be a string&#x22;);
        try {
            transport_factory_klass = autobahn.transports.get(transport_options.type);
            if (transport_factory_klass) {
                transport_factory = new transport_factory_klass(transport_options);
                this._transport_factories.push(transport_factory);
            }
        } catch (exc) {
            console.error(exc);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      {
         type: &#x27;websocket&#x27;,
         url: self._options.url
      }
   ];
}
self._transport_factories = [];
self.<span class="apidocCodeKeywordSpan">_init_transport_factories</span>();


// WAMP session
//
self._session = null;
self._session_close_reason = null;
self._session_close_message = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Connection.prototype.close" id="apidoc.element.autobahn.Connection.prototype.close">
        function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>close
        <span class="apidocSignatureSpan">(reason, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (reason, message) {
   var self = this;

   if (!self._transport &#x26;&#x26; !self._is_retrying) {
      throw &#x22;connection already closed&#x22;;
   }

   // the app wants to close .. don&#x27;t retry
   self._retry = false;

   if (self._session &#x26;&#x26; self._session.isOpen) {
      // if there is an open session, close that first.
      self._session.leave(reason, message);
   } else if (self._transport) {
      // no session active: just close the transport
      self._transport.close(1000);
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

This will establish an underlying transport and create a new session running over the transport. WebSocket is the default transport
, but for environments which do not support WebSocket (like really old browsers) HTTP long-poll can be used as a fallback.

When the transport is lost, automatic reconnection will be attempted. This can be configured using the `options` provided to the
 constructor of the `Connection` (see [Connection Options](#connection-options)).

To **close a connection**:

    autobahn.connection.<span class="apidocCodeKeywordSpan">close</span>(reason, message)

where both arguments are optional.

* `reason` is a *WAMP URI* providing a closing reason e.g. &#x27;com.myapp.close.signout&#x27; to the server side. If no reason
is given, the default URI `wamp.goodbye.normal` is sent.
* `message` is a *string*, to be used as a human-readable closing message

This returns a *string* on connection close error, else *undefined*.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Connection.prototype.open" id="apidoc.element.autobahn.Connection.prototype.open">
        function <span class="apidocSignatureSpan">autobahn.Connection.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {

   var self = this;

   if (self._transport) {
      throw &#x22;connection already open (or opening)&#x22;;
   }

   self._autoreconnect_reset();
   self._retry = true;

   function retry () {

      // create a WAMP transport
      try {
         self._transport = self._create_transport();
      } catch (e) {
         console.log(e);
      }

      if (!self._transport) {
         // failed to create a WAMP transport
         self._retry = false;
         if (self.onclose) {
            var details = {
               reason: null,
               message: null,
               retry_delay: null,
               retry_count: null,
               will_retry: false
            };
            self.onclose(&#x22;unsupported&#x22;, details);
         }
         return;
      }

      // create a new WAMP session using the WebSocket connection as transport
      self._session = new session.Session(self._transport, self._defer, self._options.onchallenge);
      self._session_close_reason = null;
      self._session_close_message = null;

      self._transport.onopen = function () {

         // reset auto-reconnect timer and tracking
         self._autoreconnect_reset();

         // log successful connections
         self._connect_successes += 1;

         // start WAMP session
         self._session.join(self._options.realm, self._options.authmethods, self._options.authid, self._options.authextra);
      };

      self._session.onjoin = function (details) {
         if (self.onopen) {
            try {
               // forward transport info ..
               details.transport = self._transport.info;
               self.onopen(self._session, details);
            } catch (e) {
               log.debug(&#x22;Exception raised from app code while firing Connection.onopen()&#x22;, e);
            }
         }
      };

      //
      // ... WAMP session is now attached to realm.
      //

      self._session.onleave = function (reason, details) {
         self._session_close_reason = reason;
         self._session_close_message = details.message || &#x22;&#x22;;
         self._retry = false;
         self._transport.close(1000);
      };

      self._transport.onclose = function (evt) {

         // remove any pending reconnect timer
         self._autoreconnect_reset_timer();

         self._transport = null;

         var reason = null;
         if (self._connect_successes === 0) {
            reason = &#x22;unreachable&#x22;;
            if (!self._retry_if_unreachable) {
               self._retry = false;
            }

         } else if (!evt.wasClean) {
            reason = &#x22;lost&#x22;;

         } else {
            reason = &#x22;closed&#x22;;
         }

         var next_retry = self._autoreconnect_advance();

         // fire app code handler
         //
         if (self.onclose) {
            var details = {
               reason: self._session_close_reason,
               message: self._session_close_message,
               retry_delay: next_retry.delay,
               retry_count: next_retry.count,
               will_retry: next_retry.will_retry
            };
            try {
               // Connection.onclose() allows to cancel any subsequent retry attempt
               var stop_retrying = self.onclose(reason, details);
            } catch (e) {
               log.debug(&#x22;Exception raised from app code while firing Connection.onclose()&#x22;, e);
            }
         }

         // reset session info
         //
         if (self._session) {
            self._session._id = null;
            self._session = null;
            self._session_close_reason = null;
            self._session_close_message = null;
         }

         // automatic reconnection
         //
         if (self._retry &#x26;&#x26; !stop_retrying) {

            if (next_retry.will_retry) {

               self._is_retrying = true;

               log.debug(&#x22;retrying in &#x22; + next_retry.delay + &#x22; s&#x22;);
               self._retry_timer = setTimeout(retry, next_retry.delay * 1000);

            } else {
               log.debug(&#x22;giving up trying to reconnect&#x22;);
            }
         }
      }
   }

   re ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   session.call(&#x27;com.myapp.add2&#x27;, [2, 3]).then(
      function (res) {
         console.log(&#x22;Result:&#x22;, res);
      }
   );
};

connection.<span class="apidocCodeKeywordSpan">open</span>();
```

Features
--------

* supports WAMP v2, works with any WAMP server
* works both in the browser and Node.js
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.Registration" id="apidoc.module.autobahn.Registration">module autobahn.Registration</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.Registration.Registration" id="apidoc.element.autobahn.Registration.Registration">
        function <span class="apidocSignatureSpan">autobahn.</span>Registration
        <span class="apidocSignatureSpan">(procedure, endpoint, options, session, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Registration = function (procedure, endpoint, options, session, id) {

   var self = this;

   self.procedure = procedure;
   self.endpoint = endpoint;
   self.options = options || {};
   self.session = session;
   self.id = id;

   self.active = true;

   // this will fire when the endpoint is unregistered
   self._on_unregister = session._defer();

   if (self._on_unregister.promise.then) {
      // whenjs has the actual user promise in an attribute
      self.on_unregister = self._on_unregister.promise;
   } else {
      self.on_unregister = self._on_unregister;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.Registration.prototype" id="apidoc.module.autobahn.Registration.prototype">module autobahn.Registration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.Registration.prototype.unregister" id="apidoc.element.autobahn.Registration.prototype.unregister">
        function <span class="apidocSignatureSpan">autobahn.Registration.prototype.</span>unregister
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unregister = function () {

   var self = this;
   return self.session.unregister(self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3e; Caution: This property and the registration objects returned should be considered read-only. DO NOT MODIFY.

Unregistering
-------------

You can unregister a previously established `registration`

    Session.<span class="apidocCodeKeywordSpan">unregister</span>(registration)

where registration is an instance of autobahn.Registration and which returns a *promise* that resolves with no value when successful
 or rejects with an instance of ``autobahn.Error`` when unsuccessful.


Example: **Unregistering a registration**

``` js
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.Session" id="apidoc.module.autobahn.Session">module autobahn.Session</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.Session.Session" id="apidoc.element.autobahn.Session.Session">
        function <span class="apidocSignatureSpan">autobahn.</span>Session
        <span class="apidocSignatureSpan">(socket, defer, onchallenge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Session = function (socket, defer, onchallenge) {

   var self = this;

   // the transport connection (WebSocket object)
   self._socket = socket;

   // the Deferred factory to use
   self._defer = defer;

   // the WAMP authentication challenge handler
   self._onchallenge = onchallenge;

   // the WAMP session ID
   self._id = null;

   // the WAMP realm joined
   self._realm = null;

   // the WAMP features in use
   self._features = null;

   // closing state
   self._goodbye_sent = false;
   self._transport_is_closing = false;

   // outstanding requests;
   self._publish_reqs = {};
   self._subscribe_reqs = {};
   self._unsubscribe_reqs = {};
   self._call_reqs = {};
   self._register_reqs = {};
   self._unregister_reqs = {};

   // subscriptions in place;
   self._subscriptions = {};

   // registrations in place;
   self._registrations = {};

   // incoming invocations;
   self._invocations = {};

   // prefix shortcuts for URIs
   self._prefixes = {};

   // the defaults for &#x27;disclose_me&#x27;
   self._caller_disclose_me = false;
   self._publisher_disclose_me = false;

   self._send_wamp = function (msg) {
      log.debug(msg);
      // forward WAMP message to be sent to WAMP transport
      self._socket.send(msg);
   };


   self._protocol_violation = function (reason) {
      log.warn(&#x22;failing transport due to protocol violation: &#x22; + reason);
      self._socket.close(1002, &#x22;protocol violation: &#x22; + reason);
   };

   self._MESSAGE_MAP = {};
   self._MESSAGE_MAP[MSG_TYPE.ERROR] = {};


   self._process_SUBSCRIBED = function (msg) {
      //
      // process SUBSCRIBED reply to SUBSCRIBE
      //
      var request = msg[1];
      var subscription = msg[2];

      if (request in self._subscribe_reqs) {

         var r = self._subscribe_reqs[request];

         var d = r[0];
         var topic = r[1];
         var handler = r[2];
         var options = r[3];

         if (!(subscription in self._subscriptions)) {
            self._subscriptions[subscription] = [];
         }
         var sub = new Subscription(topic, handler, options, self, subscription);
         self._subscriptions[subscription].push(sub);

         d.resolve(sub);

         delete self._subscribe_reqs[request];

      } else {
         self._protocol_violation(&#x22;SUBSCRIBED received for non-pending request ID &#x22; + request);
      }
   };
   self._MESSAGE_MAP[MSG_TYPE.SUBSCRIBED] = self._process_SUBSCRIBED;


   self._process_SUBSCRIBE_ERROR = function (msg) {
      //
      // process ERROR reply to SUBSCRIBE
      //
      var request = msg[2];
      if (request in self._subscribe_reqs) {

         var details = msg[3];
         var error = new Error(msg[4], msg[5], msg[6]);

         var r = self._subscribe_reqs[request];

         var d = r[0];

         d.reject(error);

         delete self._subscribe_reqs[request];

      } else {
         self._protocol_violation(&#x22;SUBSCRIBE-ERROR received for non-pending request ID &#x22; + request);
      }
   };
   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.SUBSCRIBE] = self._process_SUBSCRIBE_ERROR;


   self._process_UNSUBSCRIBED = function (msg) {
      //
      // process UNSUBSCRIBED reply to UNSUBSCRIBE
      //
      var request = msg[1];

      if (request in self._unsubscribe_reqs) {

         var r = self._unsubscribe_reqs[request];

         var d = r[0];
         var subscription_id = r[1];

         if (subscription_id in self._subscriptions) {
            var subs = self._subscriptions[subscription_id];
            // the following should actually be NOP, since UNSUBSCRIBE was
            // only sent when subs got empty
            for (var i = 0; i &#x3c; subs.length; ++i) {
               subs[i].active = false;
               subs[i].on_unsubscribe.resolve();
            }
            delete self._subscriptions[subscription_id];
         }

         d.resolve(true);

         delete self._unsubscribe_reqs[request];

      } else {

         if (request === 0) {

            // router actively revoked our subscription
            //
            var details = msg[2];
            var subscription_id = details.sub ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   };
   self.onclose(&#x22;unsupported&#x22;, details);
}
return;
      }

      // create a new WAMP session using the WebSocket connection as transport
      self._session = new session.<span class="apidocCodeKeywordSpan">Session</span>(self._transport, self._defer, self._options
.onchallenge);
      self._session_close_reason = null;
      self._session_close_message = null;

      self._transport.onopen = function () {

// reset auto-reconnect timer and tracking
self._autoreconnect_reset();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.Session.prototype" id="apidoc.module.autobahn.Session.prototype">module autobahn.Session.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.call" id="apidoc.element.autobahn.Session.prototype.call">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>call
        <span class="apidocSignatureSpan">(procedure, args, kwargs, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">call = function (procedure, args, kwargs, options) {

   util.assert(typeof procedure === &#x27;string&#x27;, &#x22;Session.call: &#x3c;procedure&#x3e; must be a string&#x22;);
   util.assert(!args || Array.isArray(args), &#x22;Session.call: &#x3c;args&#x3e; must be an array []&#x22;);
   util.assert(!kwargs || kwargs instanceof Object, &#x22;Session.call: &#x3c;kwargs&#x3e; must be an object {}&#x22;);
   util.assert(!options || options instanceof Object, &#x22;Session.call: &#x3c;options&#x3e; must be an object {}&#x22;);

   var self = this;

   if (!self.isOpen) {
      throw &#x22;session not open&#x22;;
   }

   options = options || {};

   // only set option if user hasn&#x27;t set a value and global option is &#x22;on&#x22;
   if (options.disclose_me === undefined &#x26;&#x26; self._caller_disclose_me) {
      options.disclose_me = true;
   }

   // create and remember new CALL request
   //
   var d = self._defer();
   var request = self._socket.serializer.newid();
   self._call_reqs[request] = [d, options];

   // construct CALL message
   //
   var msg = [MSG_TYPE.CALL, request, options, self.resolve(procedure)];
   if (args) {
      msg.push(args);
      if (kwargs) {
         msg.push(kwargs);
      }
   } else if (kwargs) {
      msg.push([]);
      msg.push(kwargs);
   }

   // send WAMP message
   //
   self._send_wamp(msg);

   if (d.promise.then) {
      // whenjs has the actual user promise in an attribute
      return d.promise;
   } else {
      return d;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // 3) register a procedure for remoting
   function add2(args) {
      return args[0] + args[1];
   }
   session.register(&#x27;com.myapp.add2&#x27;, add2);

   // 4) call a remote procedure
   session.<span class="apidocCodeKeywordSpan">call</span>(&#x27;com.myapp.add2&#x27;, [2, 3]).then(
      function (res) {
         console.log(&#x22;Result:&#x22;, res);
      }
   );
};

connection.open();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.join" id="apidoc.element.autobahn.Session.prototype.join">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>join
        <span class="apidocSignatureSpan">(realm, authmethods, authid, authextra)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (realm, authmethods, authid, authextra) {

   util.assert(typeof realm === &#x27;string&#x27;, &#x22;Session.join: &#x3c;realm&#x3e; must be a string&#x22;);
   util.assert(!authmethods || Array.isArray(authmethods), &#x22;Session.join: &#x3c;authmethods&#x3e; must be an array []&#x22;);
   util.assert(!authid || typeof authid === &#x27;string&#x27;, &#x22;Session.join: &#x3c;authid&#x3e; must be a string&#x22;);

   var self = this;

   if (self.isOpen) {
      throw &#x22;session already open&#x22;;
   }

   self._goodbye_sent = false;
   self._realm = realm;

   var details = {};
   details.roles = WAMP_FEATURES;

   if (authmethods) {
      details.authmethods = authmethods;
   }
   if (authid) {
      details.authid = authid;
   }
   if (authextra) {
      details.authextra = authextra;
   }

   var msg = [MSG_TYPE.HELLO, realm, details];
   self._send_wamp(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

env[&#x27;JS_DEFINES&#x27;] = {
#   &#x27;AUTOBAHNJS_VERSION&#x27;: &#x22;&#x27;%s&#x27;&#x22; % version
}

# Source for Autobahn package
sourcedir = &#x27;lib&#x27;
sources = [os.path.<span class="apidocCodeKeywordSpan">join</span>(sourcedir, d) for d in os.listdir(sourcedir)]

# browserified
ab = env.Command(&#x22;build/autobahn.js&#x22;,
                 &#x22;lib/autobahn.js&#x22;,
                 &#x22;/usr/local/lib/node_modules/browserify/bin/cmd.js $SOURCE --ignore-missing --standalone autobahn -o $TARGET
&#x22;)
Depends(ab, sources)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.leave" id="apidoc.element.autobahn.Session.prototype.leave">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>leave
        <span class="apidocSignatureSpan">(reason, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leave = function (reason, message) {

   util.assert(!reason || typeof reason === &#x27;string&#x27;, &#x22;Session.leave: &#x3c;reason&#x3e; must be a string&#x22;);
   util.assert(!message || typeof message === &#x27;string&#x27;, &#x22;Session.leave: &#x3c;message&#x3e; must be a string&#x22;);

   var self = this;

   if (!self.isOpen) {
      throw &#x22;session not open&#x22;;
   }

   if (!reason) {
      reason = &#x22;wamp.close.normal&#x22;;
   }

   var details = {};
   if (message) {
      details.message = message;
   }

   var msg = [MSG_TYPE.GOODBYE, details, reason];
   self._send_wamp(msg);
   self._goodbye_sent = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }

   // the app wants to close .. don&#x27;t retry
   self._retry = false;

   if (self._session &#x26;&#x26; self._session.isOpen) {
      // if there is an open session, close that first.
      self._session.<span class="apidocCodeKeywordSpan">leave</span>(reason, message);
   } else if (self._transport) {
      // no session active: just close the transport
      self._transport.close(1000);
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.log" id="apidoc.element.autobahn.Session.prototype.log">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
   var self = this;

   if (&#x27;console&#x27; in global) {

      var header = null;
      if (self._id &#x26;&#x26; self._created) {

         var now = null;
         if (&#x27;performance&#x27; in global &#x26;&#x26; &#x27;now&#x27; in performance) {
            now = performance.now() - self._created;
         } else {
            now = Date.now() - self._created;
         }

         header = &#x22;WAMP session &#x22; + self._id + &#x22; on &#x27;&#x22; + self._realm + &#x22;&#x27; at &#x22; + Math.round(now * 1000) / 1000 + &#x22; ms&#x22;;
      } else {
         header = &#x22;WAMP session&#x22;;
      }

      if (&#x27;group&#x27; in console) {
         console.group(header);
         for (var i = 0; i &#x3c; arguments.length; i += 1) {
            console.log(arguments[i]);
         }
         console.groupEnd();
      } else {
         var items = [header + &#x22;: &#x22;];
         for (var i = 0; i &#x3c; arguments.length; i += 1) {
            items.push(arguments[i]);
         }
         console.log.apply(console, items);
      }
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var connection = new autobahn.Connection({url: &#x27;ws://127.0.0.1:9000/&#x27;, realm: &#x27;realm1&#x27;});

connection.onopen = function (session) {

// 1) subscribe to a topic
function onevent(args) {
   console.<span class="apidocCodeKeywordSpan">log</span>(&#x22;Event:&#x22;, args[0]);
}
session.subscribe(&#x27;com.myapp.hello&#x27;, onevent);

// 2) publish an event
session.publish(&#x27;com.myapp.hello&#x27;, [&#x27;Hello, world!&#x27;]);

// 3) register a procedure for remoting
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.prefix" id="apidoc.element.autobahn.Session.prototype.prefix">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>prefix
        <span class="apidocSignatureSpan">(prefix, uri)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prefix = function (prefix, uri) {

   util.assert(typeof prefix === &#x27;string&#x27;, &#x22;Session.prefix: &#x3c;prefix&#x3e; must be a string&#x22;);
   util.assert(!uri || typeof uri === &#x27;string&#x27;, &#x22;Session.prefix: &#x3c;uri&#x3e; must be a string or falsy&#x22;);

   var self = this;

   if (uri) {
      self._prefixes[prefix] = uri;
   } else {
      if (prefix in self._prefixes) {
         delete self._prefixes[prefix];
      }
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The log method will log the WAMP session ID and the realm of the session, as well as a timestamp that provides the time elapsed
since the *construction* of the `autobahn.Session` object.

URI Shortcuts
-------------

Establish an URI prefix to be used as a shortcut in WAMp interactions on `session`:

    Session.<span class="apidocCodeKeywordSpan">prefix</span>(shortcut, prefix)

where

* `shortcut` is a *string*
* `prefix` is an URI part

&#x3e; **note**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.publish" id="apidoc.element.autobahn.Session.prototype.publish">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>publish
        <span class="apidocSignatureSpan">(topic, args, kwargs, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (topic, args, kwargs, options) {

   util.assert(typeof topic === &#x27;string&#x27;, &#x22;Session.publish: &#x3c;topic&#x3e; must be a string&#x22;);
   util.assert(!args || Array.isArray(args), &#x22;Session.publish: &#x3c;args&#x3e; must be an array []&#x22;);
   util.assert(!kwargs || kwargs instanceof Object, &#x22;Session.publish: &#x3c;kwargs&#x3e; must be an object {}&#x22;);
   util.assert(!options || options instanceof Object, &#x22;Session.publish: &#x3c;options&#x3e; must be an object {}&#x22;);

   var self = this;

   if (!self.isOpen) {
      throw &#x22;session not open&#x22;;
   }

   options = options || {};

   // only set option if user hasn&#x27;t set a value and global option is &#x22;on&#x22;
   if (options.disclose_me === undefined &#x26;&#x26; self._publisher_disclose_me) {
      options.disclose_me = true;
   }

   // create and remember new PUBLISH request
   //
   var d = null;
   var request = self._socket.serializer.newid();
   if (options.acknowledge) {
      d = self._defer();
      self._publish_reqs[request] = [d, options];
   }

   // construct PUBLISH message
   //
   var msg = [MSG_TYPE.PUBLISH, request, options, self.resolve(topic)];
   if (args) {
      msg.push(args);
      if (kwargs) {
         msg.push(kwargs);
      }
   } else if (kwargs) {
      msg.push([]);
      msg.push(kwargs);
   }

   // send WAMP message
   //
   self._send_wamp(msg);

   if (d) {
      if (d.promise.then) {
         // whenjs has the actual user promise in an attribute
         return d.promise;
      } else {
         return d;
      }
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 1) subscribe to a topic
function onevent(args) {
   console.log(&#x22;Event:&#x22;, args[0]);
}
session.subscribe(&#x27;com.myapp.hello&#x27;, onevent);

// 2) publish an event
session.<span class="apidocCodeKeywordSpan">publish</span>(&#x27;com.myapp.hello&#x27;, [&#x27;Hello, world!&#x27;]);

// 3) register a procedure for remoting
function add2(args) {
   return args[0] + args[1];
}
session.register(&#x27;com.myapp.add2&#x27;, add2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.register" id="apidoc.element.autobahn.Session.prototype.register">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>register
        <span class="apidocSignatureSpan">(procedure, endpoint, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (procedure, endpoint, options) {

   util.assert(typeof procedure === &#x27;string&#x27;, &#x22;Session.register: &#x3c;procedure&#x3e; must be a string&#x22;);
   util.assert(typeof endpoint === &#x27;function&#x27;, &#x22;Session.register: &#x3c;endpoint&#x3e; must be a function&#x22;);
   util.assert(!options || options instanceof Object, &#x22;Session.register: &#x3c;options&#x3e; must be an object {}&#x22;);

   var self = this;

   if (!self.isOpen) {
      throw &#x22;session not open&#x22;;
   }

   // create an remember new REGISTER request
   //
   var request = self._socket.serializer.newid();
   var d = self._defer();
   self._register_reqs[request] = [d, procedure, endpoint, options];

   // construct REGISTER message
   //
   var msg = [MSG_TYPE.REGISTER, request];
   if (options) {
      msg.push(options);
   } else {
      msg.push({});
   }
   msg.push(self.resolve(procedure));

   // send WAMP message
   //
   self._send_wamp(msg);

   if (d.promise.then) {
      // whenjs has the actual user promise in an attribute
      return d.promise;
   } else {
      return d;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 2) publish an event
session.publish(&#x27;com.myapp.hello&#x27;, [&#x27;Hello, world!&#x27;]);

// 3) register a procedure for remoting
function add2(args) {
   return args[0] + args[1];
}
session.<span class="apidocCodeKeywordSpan">register</span>(&#x27;com.myapp.add2&#x27;, add2);

// 4) call a remote procedure
session.call(&#x27;com.myapp.add2&#x27;, [2, 3]).then(
   function (res) {
      console.log(&#x22;Result:&#x22;, res);
   }
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.resolve" id="apidoc.element.autobahn.Session.prototype.resolve">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>resolve
        <span class="apidocSignatureSpan">(curie)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (curie) {

   util.assert(typeof curie === &#x27;string&#x27;, &#x22;Session.resolve: &#x3c;curie&#x3e; must be a string&#x22;);

   var self = this;

   // skip if not a CURIE
   var i = curie.indexOf(&#x22;:&#x22;);
   if (i &#x3e;= 0) {
      var prefix = curie.substring(0, i);
      if (prefix in self._prefixes) {
         return self._prefixes[prefix] + &#x27;.&#x27; + curie.substring(i + 1);
      } else {
         return curie;
      }
   } else {
      return curie;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` js
session.prefix(&#x27;api&#x27;, null);
```

To resolve a prefix *(normally not needed in user code)*:

``` js
session.<span class="apidocCodeKeywordSpan">resolve</span>(&#x27;api:add2&#x27;);
```

Session Meta-Events &#x26; Procedures
--------------------------------

Some WAMP routers (such as [Crossbar.io](http://crossbar.io)) provide the possibility to subscribe to events which are created by
 the router based on session lifecycle, as well as procedures which allow the retrieval of information about current sessions. For
 more information see the [Crossbar.io documenation](http://crossbar.io/docs/Session-Metaevents-and-Procedures/).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.subscribe" id="apidoc.element.autobahn.Session.prototype.subscribe">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(topic, handler, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (topic, handler, options) {

   util.assert(typeof topic === &#x27;string&#x27;, &#x22;Session.subscribe: &#x3c;topic&#x3e; must be a string&#x22;);
   util.assert(typeof handler === &#x27;function&#x27;, &#x22;Session.subscribe: &#x3c;handler&#x3e; must be a function&#x22;);
   util.assert(!options || options instanceof Object, &#x22;Session.subscribe: &#x3c;options&#x3e; must be an object {}&#x22;);

   var self = this;

   if (!self.isOpen) {
      throw &#x22;session not open&#x22;;
   }

   // create an remember new SUBSCRIBE request
   //
   var request = self._socket.serializer.newid();
   var d = self._defer();
   self._subscribe_reqs[request] = [d, topic, handler, options];

   // construct SUBSCRIBE message
   //
   var msg = [MSG_TYPE.SUBSCRIBE, request];
   if (options) {
      msg.push(options);
   } else {
      msg.push({});
   }
   msg.push(self.resolve(topic));

   // send WAMP message
   //
   self._send_wamp(msg);

   if (d.promise.then) {
      // whenjs has the actual user promise in an attribute
      return d.promise;
   } else {
      return d;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

connection.onopen = function (session) {

// 1) subscribe to a topic
function onevent(args) {
   console.log(&#x22;Event:&#x22;, args[0]);
}
session.<span class="apidocCodeKeywordSpan">subscribe</span>(&#x27;com.myapp.hello&#x27;, onevent);

// 2) publish an event
session.publish(&#x27;com.myapp.hello&#x27;, [&#x27;Hello, world!&#x27;]);

// 3) register a procedure for remoting
function add2(args) {
   return args[0] + args[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.unregister" id="apidoc.element.autobahn.Session.prototype.unregister">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>unregister
        <span class="apidocSignatureSpan">(registration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unregister = function (registration) {

   util.assert(registration instanceof Registration, &#x22;Session.unregister: &#x3c;registration&#x3e; must be an instance of class autobahn.Registration
&#x22;);

   var self = this;

   if (!self.isOpen) {
      throw &#x22;session not open&#x22;;
   }

   if (!registration.active || !(registration.id in self._registrations)) {
      throw &#x22;registration not active&#x22;;
   }

   // create and remember new UNREGISTER request
   //
   var request = self._socket.serializer.newid();
   var d = self._defer();
   self._unregister_reqs[request] = [d, registration];

   // construct UNREGISTER message
   //
   var msg = [MSG_TYPE.UNREGISTER, request, registration.id];

   // send WAMP message
   //
   self._send_wamp(msg);

   if (d.promise.then) {
      // whenjs has the actual user promise in an attribute
      return d.promise;
   } else {
      return d;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3e; Caution: This property and the registration objects returned should be considered read-only. DO NOT MODIFY.

Unregistering
-------------

You can unregister a previously established `registration`

    Session.<span class="apidocCodeKeywordSpan">unregister</span>(registration)

where registration is an instance of autobahn.Registration and which returns a *promise* that resolves with no value when successful
 or rejects with an instance of ``autobahn.Error`` when unsuccessful.


Example: **Unregistering a registration**

``` js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.Session.prototype.unsubscribe" id="apidoc.element.autobahn.Session.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">autobahn.Session.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">(subscription)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function (subscription) {

   util.assert(subscription instanceof Subscription, &#x22;Session.unsubscribe: &#x3c;subscription&#x3e; must be an instance of class autobahn.
Subscription&#x22;);

   var self = this;

   if (!self.isOpen) {
      throw &#x22;session not open&#x22;;
   }

   if (!subscription.active || !(subscription.id in self._subscriptions)) {
      throw &#x22;subscription not active&#x22;;
   }

   var subs = self._subscriptions[subscription.id];
   var i = subs.indexOf(subscription);

   if (i === -1) {
      throw &#x22;subscription not active&#x22;;
   }

   // remove handler subscription
   subs.splice(i, 1);
   subscription.active = false;

   var d = self._defer();

   if (subs.length) {
      // there are still handlers on the subscription ..
      d.resolve(false);

   } else {

      // no handlers left ..

      // create and remember new UNSUBSCRIBE request
      //
      var request = self._socket.serializer.newid();
      self._unsubscribe_reqs[request] = [d, subscription.id];

      // construct UNSUBSCRIBE message
      //
      var msg = [MSG_TYPE.UNSUBSCRIBE, request, subscription.id];

      // send WAMP message
      //
      self._send_wamp(msg);
   }

   if (d.promise.then) {
      // whenjs has the actual user promise in an attribute
      return d.promise;
   } else {
      return d;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3e; Caution: This property and the subscription objects returned should be considered read-only. DO NOT MODIFY.

Unsubscribing
-------------

You can unsubscribe a previously established `subscription`

    Session.<span class="apidocCodeKeywordSpan">unsubscribe</span>(subscription)

where `subscription` is an instance of `autobahn.Subscrioption` and which returns a *promise* that resolves to a boolean when successful
 or rejects with an instance of `autobahn.Error` when unsuccessful.

&#x3e; **note**
&#x3e;
&#x3e; If successful, the boolean returned indicates whether the underlying WAMP subscription was actually ended (`true`) or not
, since there still are application handlers in place due to multiple client-side subscriptions for the same WAMP subscription to
 the broker.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.Subscription" id="apidoc.module.autobahn.Subscription">module autobahn.Subscription</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.Subscription.Subscription" id="apidoc.element.autobahn.Subscription.Subscription">
        function <span class="apidocSignatureSpan">autobahn.</span>Subscription
        <span class="apidocSignatureSpan">(topic, handler, options, session, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Subscription = function (topic, handler, options, session, id) {

   var self = this;

   self.topic = topic;
   self.handler = handler;
   self.options = options || {};
   self.session = session;
   self.id = id;

   self.active = true;

   // this will fire when the handler is unsubscribed
   self._on_unsubscribe = session._defer();

   if (self._on_unsubscribe.promise.then) {
      // whenjs has the actual user promise in an attribute
      self.on_unsubscribe = self._on_unsubscribe.promise;
   } else {
      self.on_unsubscribe = self._on_unsubscribe;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.Subscription.prototype" id="apidoc.module.autobahn.Subscription.prototype">module autobahn.Subscription.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.Subscription.prototype.unsubscribe" id="apidoc.element.autobahn.Subscription.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">autobahn.Subscription.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function () {

   var self = this;
   return self.session.unsubscribe(self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3e; Caution: This property and the subscription objects returned should be considered read-only. DO NOT MODIFY.

Unsubscribing
-------------

You can unsubscribe a previously established `subscription`

    Session.<span class="apidocCodeKeywordSpan">unsubscribe</span>(subscription)

where `subscription` is an instance of `autobahn.Subscrioption` and which returns a *promise* that resolves to a boolean when successful
 or rejects with an instance of `autobahn.Error` when unsuccessful.

&#x3e; **note**
&#x3e;
&#x3e; If successful, the boolean returned indicates whether the underlying WAMP subscription was actually ended (`true`) or not
, since there still are application handlers in place due to multiple client-side subscriptions for the same WAMP subscription to
 the broker.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.auth_cra" id="apidoc.module.autobahn.auth_cra">module autobahn.auth_cra</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.auth_cra.derive_key" id="apidoc.element.autobahn.auth_cra.derive_key">
        function <span class="apidocSignatureSpan">autobahn.auth_cra.</span>derive_key
        <span class="apidocSignatureSpan">(secret, salt, iterations, keylen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function derive_key(secret, salt, iterations, keylen) {
   var iterations = iterations || 1000;
   var keylen = keylen || 32;
   var config = {
      keySize: keylen / 4,
      iterations: iterations,
      hasher: crypto.algo.SHA256
   }
   var key = crypto.PBKDF2(secret, salt, config);
   return key.toString(crypto.enc.Base64);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.auth_cra.sign" id="apidoc.element.autobahn.auth_cra.sign">
        function <span class="apidocSignatureSpan">autobahn.auth_cra.</span>sign
        <span class="apidocSignatureSpan">(key, challenge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(key, challenge) {
   return crypto.HmacSHA256(challenge, key).toString(crypto.enc.Base64);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.autobahn" id="apidoc.module.autobahn.autobahn">module autobahn.autobahn</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.autobahn.Connection" id="apidoc.element.autobahn.autobahn.Connection">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Connection
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection = function (options) {

   var self = this;

   self._options = options;


   // Deferred factory
   //
   if (options &#x26;&#x26; options.use_es6_promises) {

      if (&#x27;Promise&#x27; in global) {
         // ES6-based deferred factory
         //
         self._defer = function () {
            var deferred = {};

            deferred.promise = new Promise(function (resolve, reject) {
               deferred.resolve = resolve;
               deferred.reject = reject;
            });

            return deferred;
         };
      } else {

         log.debug(&#x22;Warning: ES6 promises requested, but not found! Falling back to whenjs.&#x22;);

         // whenjs-based deferred factory
         //
         self._defer = when.defer;
      }

   } else if (options &#x26;&#x26; options.use_deferred) {

      // use explicit deferred factory, e.g. jQuery.Deferred or Q.defer
      //
      self._defer = options.use_deferred;

   } else {

      // whenjs-based deferred factory
      //
      self._defer = when.defer;
   }


   // WAMP transport
   //
   // backward compatiblity
   if (!self._options.transports) {
      self._options.transports = [
         {
            type: &#x27;websocket&#x27;,
            url: self._options.url
         }
      ];
   }
   self._transport_factories = [];
   self._init_transport_factories();


   // WAMP session
   //
   self._session = null;
   self._session_close_reason = null;
   self._session_close_message = null;

   // automatic reconnection configuration
   //

   // enable automatic reconnect if host is unreachable
   if (self._options.retry_if_unreachable !== undefined) {
      self._retry_if_unreachable = self._options.retry_if_unreachable;
   } else {
      self._retry_if_unreachable = true;
   }

   // maximum number of reconnection attempts
   self._max_retries = typeof self._options.max_retries !== &#x27;undefined&#x27; ?  self._options.max_retries : 15;

   // initial retry delay in seconds
   self._initial_retry_delay = self._options.initial_retry_delay || 1.5;

   // maximum seconds between reconnection attempts
   self._max_retry_delay = self._options.max_retry_delay || 300;

   // the growth factor applied to the retry delay on each retry cycle
   self._retry_delay_growth = self._options.retry_delay_growth || 1.5;

   // the SD of a Gaussian to jitter the delay on each retry cycle
   // as a fraction of the mean
   self._retry_delay_jitter = self._options.retry_delay_jitter || 0.1;

   // reconnection tracking
   //

   // total number of successful connections
   self._connect_successes = 0;

   // controls if we should try to reconnect
   self._retry = false;

   // current number of reconnect cycles we went through
   self._retry_count = 0;

   // the current retry delay
   self._retry_delay = self._initial_retry_delay;

   // flag indicating if we are currently in a reconnect cycle
   self._is_retrying = false;

   // when retrying, this is the timer object returned from window.setTimeout()
   self._retry_timer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Callee (offers a remote procedure)

**The code runs unaltered in the browser or Node.js!**

```javascript
var autobahn = require(&#x27;autobahn&#x27;);

var connection = new autobahn.<span class="apidocCodeKeywordSpan">Connection</span>({url: &#x27;ws://127.0.0.1:9000/&#x27;, realm
: &#x27;realm1&#x27;});

connection.onopen = function (session) {

// 1) subscribe to a topic
function onevent(args) {
   console.log(&#x22;Event:&#x22;, args[0]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.Error" id="apidoc.element.autobahn.autobahn.Error">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Error
        <span class="apidocSignatureSpan">(error, args, kwargs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error = function (error, args, kwargs) {

   var self = this;

   self.error = error;
   self.args = args || [];
   self.kwargs = kwargs || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
logging this in the caller will come out something like

    wamp.error.runtime_error [&#x22;this is just an error&#x22;, &#x22;with an array of arguments&#x22;] Object {}

When defining an `autobahn.Error` object, all three properties can be defined. I.e. doing

``` js
throw new autobahn.<span class="apidocCodeKeywordSpan">Error</span>(&#x27;com.myapp.error&#x27;, [&#x27;this is a more complex error
&#x27;], {a: 23, b: 9});
```

and logging this in the caller will lead to something like

    com.myapp.error [&#x27;this is a more complex error&#x27;] Object {a: 23, b: 9}

Complete Examples:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.Event" id="apidoc.element.autobahn.autobahn.Event">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Event
        <span class="apidocSignatureSpan">(publication, topic, publisher, publisher_authid, publisher_authrole)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Event = function (publication, topic, publisher, publisher_authid, publisher_authrole) {

   var self = this;

   self.publication = publication;
   self.topic = topic;
   self.publisher = publisher;
   self.publisher_authid = publisher_authid;
   self.publisher_authrole = publisher_authrole;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.Invocation" id="apidoc.element.autobahn.autobahn.Invocation">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Invocation
        <span class="apidocSignatureSpan">(procedure, progress, caller, caller_authid, caller_authrole)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Invocation = function (procedure, progress, caller, caller_authid, caller_authrole) {

   var self = this;

   self.procedure = procedure;
   self.progress = progress;
   self.caller = caller;
   self.caller_authid = caller_authid;
   self.caller_authrole = caller_authrole;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.Publication" id="apidoc.element.autobahn.autobahn.Publication">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Publication
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Publication = function (id) {

   var self = this;
   self.id = id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.Registration" id="apidoc.element.autobahn.autobahn.Registration">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Registration
        <span class="apidocSignatureSpan">(procedure, endpoint, options, session, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Registration = function (procedure, endpoint, options, session, id) {

   var self = this;

   self.procedure = procedure;
   self.endpoint = endpoint;
   self.options = options || {};
   self.session = session;
   self.id = id;

   self.active = true;

   // this will fire when the endpoint is unregistered
   self._on_unregister = session._defer();

   if (self._on_unregister.promise.then) {
      // whenjs has the actual user promise in an attribute
      self.on_unregister = self._on_unregister.promise;
   } else {
      self.on_unregister = self._on_unregister;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.Result" id="apidoc.element.autobahn.autobahn.Result">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Result
        <span class="apidocSignatureSpan">(args, kwargs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Result = function (args, kwargs) {

   var self = this;

   self.args = args || [];
   self.kwargs = kwargs || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   connection.onopen = function (session) {

test.log(&#x27;Connected&#x27;);

function add_complex(args, kwargs) {
   test.log(&#x22;add_complex()&#x22;, args, kwargs);
   return new autobahn.<span class="apidocCodeKeywordSpan">Result</span>([], {c: args[0] + args[2], ci: args[1] + args[3]});
}

function split_name(args) {
   test.log(&#x22;split_name()&#x22;, args);
   return new autobahn.Result(args[0].split(&#x22; &#x22;));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.Session" id="apidoc.element.autobahn.autobahn.Session">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Session
        <span class="apidocSignatureSpan">(socket, defer, onchallenge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Session = function (socket, defer, onchallenge) {

   var self = this;

   // the transport connection (WebSocket object)
   self._socket = socket;

   // the Deferred factory to use
   self._defer = defer;

   // the WAMP authentication challenge handler
   self._onchallenge = onchallenge;

   // the WAMP session ID
   self._id = null;

   // the WAMP realm joined
   self._realm = null;

   // the WAMP features in use
   self._features = null;

   // closing state
   self._goodbye_sent = false;
   self._transport_is_closing = false;

   // outstanding requests;
   self._publish_reqs = {};
   self._subscribe_reqs = {};
   self._unsubscribe_reqs = {};
   self._call_reqs = {};
   self._register_reqs = {};
   self._unregister_reqs = {};

   // subscriptions in place;
   self._subscriptions = {};

   // registrations in place;
   self._registrations = {};

   // incoming invocations;
   self._invocations = {};

   // prefix shortcuts for URIs
   self._prefixes = {};

   // the defaults for &#x27;disclose_me&#x27;
   self._caller_disclose_me = false;
   self._publisher_disclose_me = false;

   self._send_wamp = function (msg) {
      log.debug(msg);
      // forward WAMP message to be sent to WAMP transport
      self._socket.send(msg);
   };


   self._protocol_violation = function (reason) {
      log.warn(&#x22;failing transport due to protocol violation: &#x22; + reason);
      self._socket.close(1002, &#x22;protocol violation: &#x22; + reason);
   };

   self._MESSAGE_MAP = {};
   self._MESSAGE_MAP[MSG_TYPE.ERROR] = {};


   self._process_SUBSCRIBED = function (msg) {
      //
      // process SUBSCRIBED reply to SUBSCRIBE
      //
      var request = msg[1];
      var subscription = msg[2];

      if (request in self._subscribe_reqs) {

         var r = self._subscribe_reqs[request];

         var d = r[0];
         var topic = r[1];
         var handler = r[2];
         var options = r[3];

         if (!(subscription in self._subscriptions)) {
            self._subscriptions[subscription] = [];
         }
         var sub = new Subscription(topic, handler, options, self, subscription);
         self._subscriptions[subscription].push(sub);

         d.resolve(sub);

         delete self._subscribe_reqs[request];

      } else {
         self._protocol_violation(&#x22;SUBSCRIBED received for non-pending request ID &#x22; + request);
      }
   };
   self._MESSAGE_MAP[MSG_TYPE.SUBSCRIBED] = self._process_SUBSCRIBED;


   self._process_SUBSCRIBE_ERROR = function (msg) {
      //
      // process ERROR reply to SUBSCRIBE
      //
      var request = msg[2];
      if (request in self._subscribe_reqs) {

         var details = msg[3];
         var error = new Error(msg[4], msg[5], msg[6]);

         var r = self._subscribe_reqs[request];

         var d = r[0];

         d.reject(error);

         delete self._subscribe_reqs[request];

      } else {
         self._protocol_violation(&#x22;SUBSCRIBE-ERROR received for non-pending request ID &#x22; + request);
      }
   };
   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.SUBSCRIBE] = self._process_SUBSCRIBE_ERROR;


   self._process_UNSUBSCRIBED = function (msg) {
      //
      // process UNSUBSCRIBED reply to UNSUBSCRIBE
      //
      var request = msg[1];

      if (request in self._unsubscribe_reqs) {

         var r = self._unsubscribe_reqs[request];

         var d = r[0];
         var subscription_id = r[1];

         if (subscription_id in self._subscriptions) {
            var subs = self._subscriptions[subscription_id];
            // the following should actually be NOP, since UNSUBSCRIBE was
            // only sent when subs got empty
            for (var i = 0; i &#x3c; subs.length; ++i) {
               subs[i].active = false;
               subs[i].on_unsubscribe.resolve();
            }
            delete self._subscriptions[subscription_id];
         }

         d.resolve(true);

         delete self._unsubscribe_reqs[request];

      } else {

         if (request === 0) {

            // router actively revoked our subscription
            //
            var details = msg[2];
            var subscription_id = details.sub ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   };
   self.onclose(&#x22;unsupported&#x22;, details);
}
return;
      }

      // create a new WAMP session using the WebSocket connection as transport
      self._session = new session.<span class="apidocCodeKeywordSpan">Session</span>(self._transport, self._defer, self._options
.onchallenge);
      self._session_close_reason = null;
      self._session_close_message = null;

      self._transport.onopen = function () {

// reset auto-reconnect timer and tracking
self._autoreconnect_reset();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.Subscription" id="apidoc.element.autobahn.autobahn.Subscription">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>Subscription
        <span class="apidocSignatureSpan">(topic, handler, options, session, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Subscription = function (topic, handler, options, session, id) {

   var self = this;

   self.topic = topic;
   self.handler = handler;
   self.options = options || {};
   self.session = session;
   self.id = id;

   self.active = true;

   // this will fire when the handler is unsubscribed
   self._on_unsubscribe = session._defer();

   if (self._on_unsubscribe.promise.then) {
      // whenjs has the actual user promise in an attribute
      self.on_unsubscribe = self._on_unsubscribe.promise;
   } else {
      self.on_unsubscribe = self._on_unsubscribe;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.auth_persona" id="apidoc.element.autobahn.autobahn.auth_persona">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>auth_persona
        <span class="apidocSignatureSpan">(session, user, extra)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auth(session, user, extra) {

   // Persona Issues:
   //
   // Chrome: https://github.com/mozilla/persona/issues/4083
   // IE11: https://groups.google.com/forum/#!topic/mozilla.dev.identity/keEkVpvfLA8

   var d = session.defer();

   navigator.id.watch({
      loggedInUser: user,
      onlogin: function (assertion) {
         // A user has logged in! Here you need to:
         // 1. Send the assertion to your backend for verification and to create a session.
         // 2. Update your UI.
         d.resolve(assertion);
      },
      onlogout: function() {
         // A user has logged out! Here you need to:
         // Tear down the user&#x27;s session by redirecting the user or making a call to your backend.
         // Also, make sure loggedInUser will get set to null on the next page load.
         // (That&#x27;s a literal JavaScript null. Not false, 0, or undefined. null.)
         session.leave(&#x22;wamp.close.logout&#x22;);
      }
   });

   if (d.promise.then) {
      // whenjs has the actual user promise in an attribute
      return d.promise;
   } else {
      return d;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.autobahn.when" id="apidoc.element.autobahn.autobahn.when">
        function <span class="apidocSignatureSpan">autobahn.autobahn.</span>when
        <span class="apidocSignatureSpan">(x, onFulfilled, onRejected, onProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length &#x3c; 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.cbor" id="apidoc.module.autobahn.cbor">module autobahn.cbor</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.cbor.Commented" id="apidoc.element.autobahn.cbor.Commented">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>Commented
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Commented extends stream.Transform {
<span class="apidocCodeCommentSpan">  /**
   * Create a CBOR commenter.
   *
   * @param {any} [options={}] - Stream options
   * @param {bool} [options.max_depth=10] - how many times to indent the dashes
   */
</span>  constructor (options) {
    options = options || {}
    options.readableObjectMode = false
    options.writableObjectMode = false
    const max_depth = (options.max_depth != null) ? options.max_depth : 10
    delete options.max_depth
    super(options)

    this.depth = 1
    this.max_depth = max_depth
    this.all = new NoFilter
    this.parser = new Decoder(options)
    this.parser.on(&#x27;value&#x27;, this._on_value.bind(this))
    this.parser.on(&#x27;start&#x27;, this._on_start.bind(this))
    this.parser.on(&#x27;start-string&#x27;, this._on_start_string.bind(this))
    this.parser.on(&#x27;stop&#x27;, this._on_stop.bind(this))
    this.parser.on(&#x27;more-bytes&#x27;, this._on_more.bind(this))
    this.parser.on(&#x27;error&#x27;, this._on_error.bind(this))
    this.parser.on(&#x27;data&#x27;, this._on_data.bind(this))
    this.parser.bs.on(&#x27;read&#x27;, this._on_read.bind(this))
  }

  /**
   * @private
   */
  _transform (fresh, encoding, cb) {
    this.parser.write(fresh, encoding, function (er) {
      cb(er)
    })
  }

  /**
   * @private
   */
  _flush (cb) {
    // TODO: find the test that covers this, and look at the return value
    return this.parser._flush(cb)
  }

  /**
   * @callback commentCallback
   * @param {Error} error - if one was generated
   * @param {string} commented - the comment string
   */

  /**
   * Comment on an input Buffer or string, creating a string passed to the
   * callback.  If callback not specified, a promise is returned.
   *
   * @static
   * @param {(string|Buffer|NoFilter)} input
   * @param {(string|object|function)} options
   * @param {number} [options.max_depth=10] - how many times to indent the dashes
   * @param {commentCallback=} cb
   * @returns {Promise} if cb not specified
   */
  static comment (input, options, cb) {
    if (input == null) {
      throw new Error(&#x27;input required&#x27;)
    }
    let encoding = (typeof input === &#x27;string&#x27;) ? &#x27;hex&#x27; : void 0
    let max_depth = 10
    switch (typeof options) {
      case &#x27;function&#x27;:
        cb = options
        break
      case &#x27;string&#x27;:
        encoding = options
        break
      case &#x27;number&#x27;:
        max_depth = options
        break
      case &#x27;object&#x27;:
        let ref1, ref2
        encoding = (ref1 = options.encoding) != null ? ref1 : encoding
        max_depth = (ref2 = options.max_depth) != null ? ref2 : max_depth
        break
      case &#x27;undefined&#x27;:
        break
      default:
        throw new Error(&#x27;Unknown option type&#x27;)
    }
    const bs = new NoFilter
    const d = new Commented({
      max_depth: max_depth
    })
    let p = null
    if (typeof cb === &#x27;function&#x27;) {
      d.on(&#x27;end&#x27;, function () {
        return cb(null, bs.toString(&#x27;utf8&#x27;))
      })
      d.on(&#x27;error&#x27;, cb)
    } else {
      p = new Promise(function (resolve, reject) {
        d.on(&#x27;end&#x27;, function () {
          return resolve(bs.toString(&#x27;utf8&#x27;))
        })
        return d.on(&#x27;error&#x27;, reject)
      })
    }
    d.pipe(bs)
    d.end(input, encoding)
    return p
  }

  /**
   * @private
   */
  _on_error (er) {
    return this.push(&#x27;ERROR: &#x27;) &#x26;&#x26;
      this.push(er.toString()) &#x26;&#x26;
      this.push(&#x27;\n&#x27;)
  }

  /**
   * @private
   */
  _on_read (buf) {
    this.all.write(buf)
    const hex = buf.toString(&#x27;hex&#x27;)
    this.push(new Array(this.depth + 1).join(&#x27;  &#x27;))
    this.push(hex)
    let ind = (this.max_depth - this.depth) * 2
    ind -= hex.length
    if (ind &#x3c; 1) {
      ind = 1
    }
    this.push(new Array(ind + 1).join(&#x27; &#x27;))
    return this.push(&#x27;-- &#x27;)
  }

  /**
   * @private
   */
  _on_more (mt, len, parent_mt, pos) {
    this.depth++
    let desc = &#x27;&#x27;
    switch (mt) {
      case MT.POS_INT:
        desc = &#x27;Positive number,&#x27;
        break
      case MT.NEG_INT:
        desc = &#x27;Negative number,&#x27;
        break
      case MT.ARRAY:
        desc = &#x27;Array, length&#x27;
        break
      case MT.MAP:
        desc = &#x27;Map, count&#x27;
        break
      case MT.BYTE_STRING:
        desc = &#x27;Byte ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.Decoder" id="apidoc.element.autobahn.cbor.Decoder">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>Decoder
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Decoder extends BinaryParseStream {

<span class="apidocCodeCommentSpan">  /**
   * Create a parsing stream.
   *
   * @param {object} [options={}]
   * @param {number} [options.max_depth=-1] - the maximum depth to parse.  Use -1 for
   *   &#x22;until you run out of memory&#x22;.  Set this to a finite positive number for
   *   un-trusted inputs.  Most standard inputs won&#x27;t nest more than
   *   100 or so levels; I&#x27;ve tested into the millions before running out of
   *   memory.
   * @param {object=} options.tags - mapping from tag number to function(v),
   *   where v is the decoded value that comes after the tag, and where the
   *   function returns the correctly-created value for that tag.
   */
</span>  constructor (options) {
    options = options || {}
    const tags = options.tags
    delete options.tags
    const max_depth = (options.max_depth != null) ? options.max_depth : -1
    delete options.max_depth
    super(options)

    this.running = true
    this.max_depth = max_depth
    this.tags = tags
  }

  /**
   * Check the given value for a symbol encoding a NULL or UNDEFINED value in
   * the CBOR stream.
   *
   * @static
   * @param {any} val - the value to check
   * @returns {any} the corrected value
   *
   * @example
   * myDecoder.on(&#x27;data&#x27;, function(val) {
   *   val = Decoder.nullcheck(val);
   *   ...
   * });
   */
  static nullcheck (val) {
    switch (val) {
      case SYMS.NULL:
        return null
      case SYMS.UNDEFINED:
        return undefined
      case NOT_FOUND:
        throw new Error(&#x27;Value not found&#x27;)
      default:
        return val
    }
  }

  /**
   * Decode the first CBOR item in the input, synchronously.  This will throw an
   * exception if the input is not valid CBOR.
   *
   * @static
   * @param {(string|Buffer)} input
   * @param {object} [options={encoding: &#x27;hex&#x27;}]
   * @param {string} [options.encoding: &#x27;hex&#x27;] - The encoding of the input.
   *   Ignored if input is a Buffer.
   * @returns {any} - the decoded value
   */
  static decodeFirstSync (input, options) {
    options = options || { encoding: &#x27;hex&#x27; }
    let opts = {}
    let encod
    switch (typeof options) {
      case &#x27;string&#x27;:
        encod = options
        break
      case &#x27;object&#x27;:
        opts = utils.extend({}, options)
        encod = opts.encoding
        delete opts.encoding
        break
    }
    const c = new Decoder(opts)
    const s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input))
    const parser = c._parse()
    let state = parser.next()
    while (!state.done) {
      const b = s.read(state.value)
      if ((b == null) || (b.length !== state.value)) {
        throw new Error(&#x27;Insufficient data&#x27;)
      }
      state = parser.next(b)
    }
    return Decoder.nullcheck(state.value)
  }

  /**
   * Decode all of the CBOR items in the input into an array.  This will throw
   * an exception if the input is not valid CBOR; a zero-length input will
   * return an empty array.
   *
   * @static
   * @param {(string|Buffer)} input
   * @param {(string|Object)} [options={encoding: &#x27;hex&#x27;}]
   * @param {string} [options.encoding: &#x27;hex&#x27;] - The encoding of the input.
   *   Ignored if input is a Buffer.
   * @returns {Array} - Array of all found items
   */
  static decodeAllSync (input, options) {
    options = options || { encoding: &#x27;hex&#x27; }
    let opts = {}
    let encod
    switch (typeof options) {
      case &#x27;string&#x27;:
        encod = options
        break
      case &#x27;object&#x27;:
        opts = utils.extend({}, options)
        encod = opts.encoding
        delete opts.encoding
    }
    const c = new Decoder(opts)
    const s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input))
    const res = []
    while (s.length &#x3e; 0) {
      const parser = c._parse()
      let state = parser.next()
      while (!state.done) {
        const b = s.read(state.value)
        if ((b == null) || (b.length !== state.value)) {
          throw new Error(&#x27;Insufficient data&#x27;)
        }
        state = parser.next(b)
      }
      res.push(Decoder.nullcheck(state.value))
    }
    return res
  }

  /**
   * @callback decodeCallb ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.Diagnose" id="apidoc.element.autobahn.cbor.Diagnose">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>Diagnose
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Diagnose extends stream.Transform {

<span class="apidocCodeCommentSpan">  /**
   * Creates an instance of Diagnose.
   *
   * @param {Object} [options={}] - options for creation
   * @param {string} [options.separator=&#x27;\n&#x27;] - output between detected objects
   * @param {bool} [options.stream_errors=false] - put error info into the
   *   output stream
   * @param {number} [options.max_depth=-1] - -1 for &#x22;until you run out of
   *   memory&#x22;.  Set this to a finite positive number for un-trusted inputs.  Most
   *   standard inputs won&#x27;t nest more than 100 or so levels; I&#x27;ve tested into the
   *   millions before running out of memory.
   */
</span>  constructor (options) {
    options = options || {}
    const separator = (options.separator != null) ? options.separator : &#x27;\n&#x27;
    delete options.separator
    const stream_errors = (options.stream_errors != null) ? options.stream_errors : false
    delete options.stream_errors
    options.readableObjectMode = false
    options.writableObjectMode = false
    super(options)

    this.float_bytes = -1
    this.separator = separator
    this.stream_errors = stream_errors
    this.parser = new Decoder(options)
    this.parser.on(&#x27;more-bytes&#x27;, this._on_more.bind(this))
    this.parser.on(&#x27;value&#x27;, this._on_value.bind(this))
    this.parser.on(&#x27;start&#x27;, this._on_start.bind(this))
    this.parser.on(&#x27;stop&#x27;, this._on_stop.bind(this))
    this.parser.on(&#x27;data&#x27;, this._on_data.bind(this))
    this.parser.on(&#x27;error&#x27;, this._on_error.bind(this))
  }

  _transform (fresh, encoding, cb) {
    return this.parser.write(fresh, encoding, cb)
  }

  _flush (cb) {
    return this.parser._flush((er) =&#x3e; {
      if (this.stream_errors) {
        this._on_error(er)
        return cb()
      } else {
        return cb(er)
      }
    })
  }

  /**
   * Convenience function to return a string in diagnostic format.
   *
   * @param {(Buffer|string)} input - the CBOR bytes to format
   * @param {string} [encoding=&#x27;hex&#x27;] - the encoding of input, ignored if input is Buffer
   * @param {commentCallback} cb - callback
   * @returns {Promise} if callback not specified
   */
  static diagnose (input, encoding, cb) {
    if (input == null) {
      throw new Error(&#x27;input required&#x27;)
    }
    let opts = {}
    let encod = &#x27;hex&#x27;
    switch (typeof encoding) {
      case &#x27;function&#x27;:
        cb = encoding
        encod = utils.guessEncoding(input)
        break
      case &#x27;object&#x27;:
        opts = utils.extend({}, encoding)
        encod = (opts.encoding != null) ? opts.encoding : utils.guessEncoding(input)
        delete opts.encoding
        break
      default:
        encod = (encoding != null) ? encoding : &#x27;hex&#x27;
    }
    const bs = new NoFilter
    const d = new Diagnose(opts)
    let p = null
    if (typeof cb === &#x27;function&#x27;) {
      d.on(&#x27;end&#x27;, function () {
        return cb(null, bs.toString(&#x27;utf8&#x27;))
      })
      d.on(&#x27;error&#x27;, cb)
    } else {
      p = new Promise(function (resolve, reject) {
        d.on(&#x27;end&#x27;, function () {
          return resolve(bs.toString(&#x27;utf8&#x27;))
        })
        return d.on(&#x27;error&#x27;, reject)
      })
    }
    d.pipe(bs)
    d.end(input, encod)
    return p
  }

  _on_error (er) {
    if (this.stream_errors) {
      return this.push(er.toString())
    } else {
      return this.emit(&#x27;error&#x27;, er)
    }
  }

  _on_more (mt, len, parent_mt, pos) {
    if (mt === MT.SIMPLE_FLOAT) {
      return this.float_bytes = (function () {
        switch (len) {
          case 2:
            return 1
          case 4:
            return 2
          case 8:
            return 3
        }
      })()
    }
  }

  _fore (parent_mt, pos) {
    switch (parent_mt) {
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
      case MT.ARRAY:
        if (pos &#x3e; 0) {
          return this.push(&#x27;, &#x27;)
        }
        break
      case MT.MAP:
        if (pos &#x3e; 0) {
          if (pos % 2) {
            return this.push(&#x27;: &#x27;)
          } else {
            return this.push(&#x27;, &#x27;)
          }
        }
    }
  }

  _on_value (val, parent_mt, pos) {
    if (val === SYMS.BREAK) {
      return
    }
    this._fore(parent_mt, pos)
    return this.push( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.Encoder" id="apidoc.element.autobahn.cbor.Encoder">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>Encoder
        <span class="apidocSignatureSpan">(Encoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Encoder extends stream.Transform {

<span class="apidocCodeCommentSpan">  /**
   * Creates an instance of Encoder.
   *
   * @param {Object} [options={}] - options for the encoder
   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,
   *   `function(Encoder)` for semantic types to be encoded.  Not needed
   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.
   * @param {boolean} [options.canonical=false] - should the output be
   *   canonicalized
   */
</span>  constructor (options) {
    options = options || {}
    options.readableObjectMode = false
    options.writableObjectMode = true
    super(options)

    this.canonical = options.canonical
    this.semanticTypes = [
      Array, this._pushArray,
      Date, this._pushDate,
      Buffer, this._pushBuffer,
      Map, this._pushMap,
      NoFilter, this._pushNoFilter,
      RegExp, this._pushRegexp,
      Set, this._pushSet,
      url.Url, this._pushUrl,
      bignumber, this._pushBigNumber
    ]

    const addTypes = options.genTypes || []
    for (let i = 0, len = addTypes.length; i &#x3c; len; i += 2) {
      this.addSemanticType(addTypes[i], addTypes[i + 1])
    }
  }

  _transform (fresh, encoding, cb) {
    const ret = this.pushAny(fresh)
    // Old transformers might not return bool.  undefined !== false
    return cb((ret === false) ? new Error(&#x27;Push Error&#x27;) : undefined)
  }

  _flush (cb) {
    return cb()
  }

  /**
   * @callback encodeFunction
   * @param {Encoder} encoder - the encoder to serialize into.  Call &#x22;write&#x22;
   *   on the encoder as needed.
   * @return {bool} - true on success, else false
   */

  /**
   * Add an encoding function to the list of supported semantic types.  This is
   * useful for objects for which you can&#x27;t add an encodeCBOR method
   *
   * @param {any} type
   * @param {any} fun
   * @returns {encodeFunction}
   */
  addSemanticType (type, fun) {
    for (let i = 0, len = this.semanticTypes.length; i &#x3c; len; i += 2) {
      const typ = this.semanticTypes[i]
      if (typ === type) {
        const old = this.semanticTypes[i + 1]
        this.semanticTypes[i + 1] = fun
        return old
      }
    }
    this.semanticTypes.push(type, fun)
    return null
  }

  _pushUInt8 (val) {
    const b = new Buffer(1)
    b.writeUInt8(val)
    return this.push(b)
  }

  _pushUInt16BE (val) {
    const b = new Buffer(2)
    b.writeUInt16BE(val)
    return this.push(b)
  }

  _pushUInt32BE (val) {
    const b = new Buffer(4)
    b.writeUInt32BE(val)
    return this.push(b)
  }

  _pushDoubleBE (val) {
    const b = new Buffer(8)
    b.writeDoubleBE(val)
    return this.push(b)
  }

  _pushNaN () {
    return this.push(BUF_NAN)
  }

  _pushInfinity (obj) {
    const half = (obj &#x3c; 0) ? BUF_INF_NEG : BUF_INF_POS
    return this.push(half)
  }

  _pushFloat (obj) {
    if (this.canonical) {
      // TODO: is this enough slower to hide behind canonical?
      // It&#x27;s certainly enough of a hack (see utils.parseHalf)

      // From section 3.9:
      // If a protocol allows for IEEE floats, then additional canonicalization
      // rules might need to be added.  One example rule might be to have all
      // floats start as a 64-bit float, then do a test conversion to a 32-bit
      // float; if the result is the same numeric value, use the shorter value
      // and repeat the process with a test conversion to a 16-bit float.  (This
      // rule selects 16-bit float for positive and negative Infinity as well.)

      // which seems pretty much backwards to me.
      const b2 = new Buffer(2)
      if (utils.writeHalf(b2, obj)) {
        if (utils.parseHalf(b2) === obj) {
          return this._pushUInt8(HALF) &#x26;&#x26; this.push(b2)
        }
      }
      const b4 = new Buffer(4)
      b4.writeFloatBE(obj)
      if (b4.readFloatBE() === obj) {
        return this._pushUInt8(FLOAT) &#x26;&#x26; this.push(b4)
      }
    }

    return this._pushUInt8(DOUBLE) &#x26;&#x26; this._pushDoubleBE(obj)
  }

  _pushInt (obj, mt, orig) {
    const m = mt &#x3c;&#x3c; 5
    switch (false) {
      case !(obj &#x3c; 24):
        return this._pushUInt8(m | obj)
      case !(obj &#x3c;= 0xff):
        return this._pus ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.Simple" id="apidoc.element.autobahn.cbor.Simple">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>Simple
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Simple {
<span class="apidocCodeCommentSpan">  /**
   * Creates an instance of Simple.
   *
   * @param {integer} value - the simple value&#x27;s integer value
   */
</span>  constructor (value) {
    if (typeof value !== &#x27;number&#x27;) {
      throw new Error(&#x27;Invalid Simple type: &#x27; + (typeof value))
    }
    if ((value &#x3c; 0) || (value &#x3e; 255) || ((value|0) !== value)) {
      throw new Error(&#x27;value must be a small positive integer: &#x27; + value)
    }
    this.value = value
  }

  /**
   * Debug string for simple value
   *
   * @returns {string} simple(value)
   */
  toString () {
    return &#x27;simple(&#x27; + this.value + &#x27;)&#x27;
  }

  /**
   * Debug string for simple value
   *
   * @returns {string} simple(value)
   */
  inspect (depth, opts) {
    return &#x27;simple(&#x27; + this.value + &#x27;)&#x27;
  }

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {cbor.Encoder} gen The generator to push onto
   */
  encodeCBOR (gen) {
    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)
  }

  /**
   * Is the given object a Simple?
   *
   * @param {any} obj - object to test
   * @returns {bool} - is it Simple?
   */
  static isSimple (obj) {
    return obj instanceof Simple
  }

  /**
   * Decode from the CBOR additional information into a JavaScript value.
   * If the CBOR item has no parent, return a &#x22;safe&#x22; symbol instead of
   * `null` or `undefined`, so that the value can be passed through a
   * stream in object mode.
   *
   * @param {Number} val - the CBOR additional info to convert
   * @param {bool} has_parent - Does the CBOR item have a parent?
   * @returns {(null|undefined|Boolean|Symbol)} - the decoded value
   */
  static decode (val, has_parent) {
    if (has_parent == null) {
      has_parent = true
    }
    switch (val) {
      case SIMPLE.FALSE:
        return false
      case SIMPLE.TRUE:
        return true
      case SIMPLE.NULL:
        if (has_parent) {
          return null
        } else {
          return SYMS.NULL
        }
      case SIMPLE.UNDEFINED:
        if (has_parent) {
          return void 0
        } else {
          return SYMS.UNDEFINED
        }
      case -1:
        if (!has_parent) {
          throw new Error(&#x27;Invalid BREAK&#x27;)
        }
        return SYMS.BREAK
      default:
        return new Simple(val)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.Tagged" id="apidoc.element.autobahn.cbor.Tagged">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>Tagged
        <span class="apidocSignatureSpan">(tag, value, err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Tagged {

<span class="apidocCodeCommentSpan">  /**
   * Creates an instance of Tagged.
   *
   * @param {Number} tag - the number of the tag
   * @param {any} value - the value inside the tag
   * @param {Error} err - the error that was thrown parsing the tag, or null
   */
</span>  constructor (tag, value, err) {
    this.tag = tag
    this.value = value
    this.err = err
    if (typeof this.tag !== &#x27;number&#x27;) {
      throw new Error(&#x27;Invalid tag type (&#x27; + (typeof this.tag) + &#x27;)&#x27;)
    }
    if ((this.tag &#x3c; 0) || ((this.tag | 0) !== this.tag)) {
      throw new Error(&#x27;Tag must be a positive integer: &#x27; + this.tag)
    }
  }

  /**
   * Convert to a String
   *
   * @returns {String} string of the form &#x27;1(2)&#x27;
   */
  toString () {
    return `${this.tag}(${JSON.stringify(this.value)})`
  }

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {cbor.Encoder} gen The generator to push onto
   */
  encodeCBOR (gen) {
    gen._pushTag(this.tag)
    return gen.pushAny(this.value)
  }

  /**
   * If we have a converter for this type, do the conversion.  Some converters
   * are built-in.  Additional ones can be passed in.  If you want to remove
   * a built-in converter, pass a converter in whose value is &#x27;null&#x27; instead
   * of a function.
   *
   * @param {Object} converters - keys in the object are a tag number, the value
   *   is a function that takes the decoded CBOR and returns a JavaScript value
   *   of the appropriate type.  Throw an exception in the function on errors.
   * @returns {any} - the converted item
   */
  convert (converters) {
    var er, f
    f = converters != null ? converters[this.tag] : void 0
    if (typeof f !== &#x27;function&#x27;) {
      f = Tagged[&#x27;_tag_&#x27; + this.tag]
      if (typeof f !== &#x27;function&#x27;) {
        return this
      }
    }
    try {
      return f.call(Tagged, this.value)
    } catch (error) {
      er = error
      this.err = er
      return this
    }
  }

  static _tag_0 (v) {
    return new Date(v)
  }

  static _tag_1 (v) {
    return new Date(v * 1000)
  }

  static _tag_2 (v) {
    return utils.bufferToBignumber(v)
  }

  static _tag_3 (v) {
    return MINUS_ONE.minus(utils.bufferToBignumber(v))
  }

  static _tag_4 (v) {
    return TEN.pow(v[0]).times(v[1])
  }

  static _tag_5 (v) {
    return TWO.pow(v[0]).times(v[1])
  }

  static _tag_32 (v) {
    return url.parse(v)
  }

  static _tag_35 (v) {
    return new RegExp(v)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.comment" id="apidoc.element.autobahn.cbor.comment">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>comment
        <span class="apidocSignatureSpan">(input, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment(input, options, cb) {
  if (input == null) {
    throw new Error(&#x27;input required&#x27;)
  }
  let encoding = (typeof input === &#x27;string&#x27;) ? &#x27;hex&#x27; : void 0
  let max_depth = 10
  switch (typeof options) {
    case &#x27;function&#x27;:
      cb = options
      break
    case &#x27;string&#x27;:
      encoding = options
      break
    case &#x27;number&#x27;:
      max_depth = options
      break
    case &#x27;object&#x27;:
      let ref1, ref2
      encoding = (ref1 = options.encoding) != null ? ref1 : encoding
      max_depth = (ref2 = options.max_depth) != null ? ref2 : max_depth
      break
    case &#x27;undefined&#x27;:
      break
    default:
      throw new Error(&#x27;Unknown option type&#x27;)
  }
  const bs = new NoFilter
  const d = new Commented({
    max_depth: max_depth
  })
  let p = null
  if (typeof cb === &#x27;function&#x27;) {
    d.on(&#x27;end&#x27;, function () {
      return cb(null, bs.toString(&#x27;utf8&#x27;))
    })
    d.on(&#x27;error&#x27;, cb)
  } else {
    p = new Promise(function (resolve, reject) {
      d.on(&#x27;end&#x27;, function () {
        return resolve(bs.toString(&#x27;utf8&#x27;))
      })
      return d.on(&#x27;error&#x27;, reject)
    })
  }
  d.pipe(bs)
  d.end(input, encoding)
  return p
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.decode" id="apidoc.element.autobahn.cbor.decode">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>decode
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeFirstSync(input, options) {
  options = options || { encoding: &#x27;hex&#x27; }
  let opts = {}
  let encod
  switch (typeof options) {
    case &#x27;string&#x27;:
      encod = options
      break
    case &#x27;object&#x27;:
      opts = utils.extend({}, options)
      encod = opts.encoding
      delete opts.encoding
      break
  }
  const c = new Decoder(opts)
  const s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input))
  const parser = c._parse()
  let state = parser.next()
  while (!state.done) {
    const b = s.read(state.value)
    if ((b == null) || (b.length !== state.value)) {
      throw new Error(&#x27;Insufficient data&#x27;)
    }
    state = parser.next(b)
  }
  return Decoder.nullcheck(state.value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
};

MsgpackSerializer.prototype.unserialize = function (payload) {
   try {
      // need to encapsulate ArrayBuffer into Uint8Array for msgpack decoding
      // https://github.com/kawanet/msgpack-lite/issues/44
      var obj = msgpack.<span class="apidocCodeKeywordSpan">decode</span>(new Uint8Array(payload), {codec: this.codec});
      return obj;
   } catch (e) {
      log.warn(&#x27;MessagePack decoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.decodeAll" id="apidoc.element.autobahn.cbor.decodeAll">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>decodeAll
        <span class="apidocSignatureSpan">(input, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeAll(input, options, cb) {
  let opts = {}
  let encod = &#x27;hex&#x27;
  switch (typeof options) {
    case &#x27;function&#x27;:
      cb = options
      encod = utils.guessEncoding(input)
      break
    case &#x27;string&#x27;:
      encod = options
      break
    case &#x27;object&#x27;:
      opts = utils.extend({}, options)
      encod = (opts.encoding != null) ? opts.encoding : utils.guessEncoding(input)
      delete opts.encoding
  }
  const c = new Decoder(opts)
  let p
  const vals = []
  c.on(&#x27;data&#x27;, function (val) {
    return vals.push(Decoder.nullcheck(val))
  })
  if (typeof cb === &#x27;function&#x27;) {
    c.on(&#x27;error&#x27;, function (er) {
      return cb(er)
    })
    c.on(&#x27;end&#x27;, function () {
      return cb(null, vals)
    })
  } else {
    p = new Promise(function (resolve, reject) {
      c.on(&#x27;error&#x27;, function (er) {
        return reject(er)
      })
      return c.on(&#x27;end&#x27;, function () {
        return resolve(vals)
      })
    })
  }
  c.end(input, encod)
  return p
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.decodeAllSync" id="apidoc.element.autobahn.cbor.decodeAllSync">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>decodeAllSync
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeAllSync(input, options) {
  options = options || { encoding: &#x27;hex&#x27; }
  let opts = {}
  let encod
  switch (typeof options) {
    case &#x27;string&#x27;:
      encod = options
      break
    case &#x27;object&#x27;:
      opts = utils.extend({}, options)
      encod = opts.encoding
      delete opts.encoding
  }
  const c = new Decoder(opts)
  const s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input))
  const res = []
  while (s.length &#x3e; 0) {
    const parser = c._parse()
    let state = parser.next()
    while (!state.done) {
      const b = s.read(state.value)
      if ((b == null) || (b.length !== state.value)) {
        throw new Error(&#x27;Insufficient data&#x27;)
      }
      state = parser.next(b)
    }
    res.push(Decoder.nullcheck(state.value))
  }
  return res
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      log.warn(&#x27;CBOR encoding error&#x27;, e);
      throw e;
   }
};

CBORSerializer.prototype.unserialize = function (payload) {
   try {
      //var obj = cbor.<span class="apidocCodeKeywordSpan">decodeAllSync</span>(payload)[0];
      var obj = cbor.decodeFirstSync(payload);
      return obj;
   } catch (e) {
      log.warn(&#x27;CBOR decoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.decodeFirst" id="apidoc.element.autobahn.cbor.decodeFirst">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>decodeFirst
        <span class="apidocSignatureSpan">(input, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeFirst(input, options, cb) {
  let opts = {}
  let required = false
  let encod = &#x27;hex&#x27;
  switch (typeof options) {
    case &#x27;function&#x27;:
      cb = options
      encod = utils.guessEncoding(input)
      break
    case &#x27;string&#x27;:
      encod = options
      break
    case &#x27;object&#x27;:
      opts = utils.extend({}, options)
      encod = (opts.encoding != null) ? opts.encoding : utils.guessEncoding(input)
      delete opts.encoding
      required = (opts.required != null) ? opts.required : false
      delete opts.required
  }
  const c = new Decoder(opts)
  let p
  let v = NOT_FOUND
  c.on(&#x27;data&#x27;, (val) =&#x3e; {
    v = Decoder.nullcheck(val)
    c.close()
  })
  if (typeof cb === &#x27;function&#x27;) {
    c.once(&#x27;error&#x27;, function (er) {
      const u = v
      v = ERROR
      c.close()
      return cb(er, u)
    })
    c.once(&#x27;end&#x27;, () =&#x3e; {
      switch (v) {
        case NOT_FOUND:
          if (required) {
            return cb(new Error(&#x27;No CBOR found&#x27;))
          } else {
            return cb(null, v)
          }
        case ERROR:
          return void 0
        default:
          return cb(null, v)
      }
    })
  } else {
    p = new Promise(function (resolve, reject) {
      c.once(&#x27;error&#x27;, (er) =&#x3e; {
        v = ERROR
        c.close()
        return reject(er)
      })
      return c.once(&#x27;end&#x27;, () =&#x3e; {
        switch (v) {
          case NOT_FOUND:
            if (required) {
              return reject(new Error(&#x27;No CBOR found&#x27;))
            } else {
              return resolve(v)
            }
          case ERROR:
            return void 0
          default:
            return resolve(v)
        }
      })
    })
  }
  c.end(input, encod)
  return p
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.decodeFirstSync" id="apidoc.element.autobahn.cbor.decodeFirstSync">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>decodeFirstSync
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeFirstSync(input, options) {
  options = options || { encoding: &#x27;hex&#x27; }
  let opts = {}
  let encod
  switch (typeof options) {
    case &#x27;string&#x27;:
      encod = options
      break
    case &#x27;object&#x27;:
      opts = utils.extend({}, options)
      encod = opts.encoding
      delete opts.encoding
      break
  }
  const c = new Decoder(opts)
  const s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input))
  const parser = c._parse()
  let state = parser.next()
  while (!state.done) {
    const b = s.read(state.value)
    if ((b == null) || (b.length !== state.value)) {
      throw new Error(&#x27;Insufficient data&#x27;)
    }
    state = parser.next(b)
  }
  return Decoder.nullcheck(state.value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      throw e;
   }
};

CBORSerializer.prototype.unserialize = function (payload) {
   try {
      //var obj = cbor.decodeAllSync(payload)[0];
      var obj = cbor.<span class="apidocCodeKeywordSpan">decodeFirstSync</span>(payload);
      return obj;
   } catch (e) {
      log.warn(&#x27;CBOR decoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.diagnose" id="apidoc.element.autobahn.cbor.diagnose">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>diagnose
        <span class="apidocSignatureSpan">(input, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diagnose(input, encoding, cb) {
  if (input == null) {
    throw new Error(&#x27;input required&#x27;)
  }
  let opts = {}
  let encod = &#x27;hex&#x27;
  switch (typeof encoding) {
    case &#x27;function&#x27;:
      cb = encoding
      encod = utils.guessEncoding(input)
      break
    case &#x27;object&#x27;:
      opts = utils.extend({}, encoding)
      encod = (opts.encoding != null) ? opts.encoding : utils.guessEncoding(input)
      delete opts.encoding
      break
    default:
      encod = (encoding != null) ? encoding : &#x27;hex&#x27;
  }
  const bs = new NoFilter
  const d = new Diagnose(opts)
  let p = null
  if (typeof cb === &#x27;function&#x27;) {
    d.on(&#x27;end&#x27;, function () {
      return cb(null, bs.toString(&#x27;utf8&#x27;))
    })
    d.on(&#x27;error&#x27;, cb)
  } else {
    p = new Promise(function (resolve, reject) {
      d.on(&#x27;end&#x27;, function () {
        return resolve(bs.toString(&#x27;utf8&#x27;))
      })
      return d.on(&#x27;error&#x27;, reject)
    })
  }
  d.pipe(bs)
  d.end(input, encod)
  return p
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.encode" id="apidoc.element.autobahn.cbor.encode">
        function <span class="apidocSignatureSpan">autobahn.cbor.</span>encode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode() {
  const objs = Array.prototype.slice.apply(arguments)
  const enc = new Encoder()
  const bs = new NoFilter()
  enc.pipe(bs)
  for (let o of objs) {
    if (typeof o === &#x27;undefined&#x27;) {
      enc._pushUndefined()
    } else if (o === null) {
      enc._pushNull(null)
    } else {
      enc.write(o)
    }
  }
  enc.end()
  return bs.read()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   // msgpack: Uint64BE ensures that ID is encoded as int instead of double
   this.newid = function () { return new Uint64BE(newid()); };
}

MsgpackSerializer.prototype.serialize = function (obj) {
   try {
      var payload = msgpack.<span class="apidocCodeKeywordSpan">encode</span>(obj, {codec: this.codec});
      return payload;
   } catch (e) {
      log.warn(&#x27;MessagePack encoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.cbor.leveldb" id="apidoc.module.autobahn.cbor.leveldb">module autobahn.cbor.leveldb</a></h1>




    <h2>
        <a href="#apidoc.element.autobahn.cbor.leveldb.decode" id="apidoc.element.autobahn.cbor.leveldb.decode">
        function <span class="apidocSignatureSpan">autobahn.cbor.leveldb.</span>decode
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeAllSync(input, options) {
  options = options || { encoding: &#x27;hex&#x27; }
  let opts = {}
  let encod
  switch (typeof options) {
    case &#x27;string&#x27;:
      encod = options
      break
    case &#x27;object&#x27;:
      opts = utils.extend({}, options)
      encod = opts.encoding
      delete opts.encoding
  }
  const c = new Decoder(opts)
  const s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input))
  const res = []
  while (s.length &#x3e; 0) {
    const parser = c._parse()
    let state = parser.next()
    while (!state.done) {
      const b = s.read(state.value)
      if ((b == null) || (b.length !== state.value)) {
        throw new Error(&#x27;Insufficient data&#x27;)
      }
      state = parser.next(b)
    }
    res.push(Decoder.nullcheck(state.value))
  }
  return res
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
};

MsgpackSerializer.prototype.unserialize = function (payload) {
   try {
      // need to encapsulate ArrayBuffer into Uint8Array for msgpack decoding
      // https://github.com/kawanet/msgpack-lite/issues/44
      var obj = msgpack.<span class="apidocCodeKeywordSpan">decode</span>(new Uint8Array(payload), {codec: this.codec});
      return obj;
   } catch (e) {
      log.warn(&#x27;MessagePack decoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.cbor.leveldb.encode" id="apidoc.element.autobahn.cbor.leveldb.encode">
        function <span class="apidocSignatureSpan">autobahn.cbor.leveldb.</span>encode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode() {
  const objs = Array.prototype.slice.apply(arguments)
  const enc = new Encoder()
  const bs = new NoFilter()
  enc.pipe(bs)
  for (let o of objs) {
    if (typeof o === &#x27;undefined&#x27;) {
      enc._pushUndefined()
    } else if (o === null) {
      enc._pushNull(null)
    } else {
      enc.write(o)
    }
  }
  enc.end()
  return bs.read()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   // msgpack: Uint64BE ensures that ID is encoded as int instead of double
   this.newid = function () { return new Uint64BE(newid()); };
}

MsgpackSerializer.prototype.serialize = function (obj) {
   try {
      var payload = msgpack.<span class="apidocCodeKeywordSpan">encode</span>(obj, {codec: this.codec});
      return payload;
   } catch (e) {
      log.warn(&#x27;MessagePack encoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.connection" id="apidoc.module.autobahn.connection">module autobahn.connection</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.connection.Connection" id="apidoc.element.autobahn.connection.Connection">
        function <span class="apidocSignatureSpan">autobahn.connection.</span>Connection
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection = function (options) {

   var self = this;

   self._options = options;


   // Deferred factory
   //
   if (options &#x26;&#x26; options.use_es6_promises) {

      if (&#x27;Promise&#x27; in global) {
         // ES6-based deferred factory
         //
         self._defer = function () {
            var deferred = {};

            deferred.promise = new Promise(function (resolve, reject) {
               deferred.resolve = resolve;
               deferred.reject = reject;
            });

            return deferred;
         };
      } else {

         log.debug(&#x22;Warning: ES6 promises requested, but not found! Falling back to whenjs.&#x22;);

         // whenjs-based deferred factory
         //
         self._defer = when.defer;
      }

   } else if (options &#x26;&#x26; options.use_deferred) {

      // use explicit deferred factory, e.g. jQuery.Deferred or Q.defer
      //
      self._defer = options.use_deferred;

   } else {

      // whenjs-based deferred factory
      //
      self._defer = when.defer;
   }


   // WAMP transport
   //
   // backward compatiblity
   if (!self._options.transports) {
      self._options.transports = [
         {
            type: &#x27;websocket&#x27;,
            url: self._options.url
         }
      ];
   }
   self._transport_factories = [];
   self._init_transport_factories();


   // WAMP session
   //
   self._session = null;
   self._session_close_reason = null;
   self._session_close_message = null;

   // automatic reconnection configuration
   //

   // enable automatic reconnect if host is unreachable
   if (self._options.retry_if_unreachable !== undefined) {
      self._retry_if_unreachable = self._options.retry_if_unreachable;
   } else {
      self._retry_if_unreachable = true;
   }

   // maximum number of reconnection attempts
   self._max_retries = typeof self._options.max_retries !== &#x27;undefined&#x27; ?  self._options.max_retries : 15;

   // initial retry delay in seconds
   self._initial_retry_delay = self._options.initial_retry_delay || 1.5;

   // maximum seconds between reconnection attempts
   self._max_retry_delay = self._options.max_retry_delay || 300;

   // the growth factor applied to the retry delay on each retry cycle
   self._retry_delay_growth = self._options.retry_delay_growth || 1.5;

   // the SD of a Gaussian to jitter the delay on each retry cycle
   // as a fraction of the mean
   self._retry_delay_jitter = self._options.retry_delay_jitter || 0.1;

   // reconnection tracking
   //

   // total number of successful connections
   self._connect_successes = 0;

   // controls if we should try to reconnect
   self._retry = false;

   // current number of reconnect cycles we went through
   self._retry_count = 0;

   // the current retry delay
   self._retry_delay = self._initial_retry_delay;

   // flag indicating if we are currently in a reconnect cycle
   self._is_retrying = false;

   // when retrying, this is the timer object returned from window.setTimeout()
   self._retry_timer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Callee (offers a remote procedure)

**The code runs unaltered in the browser or Node.js!**

```javascript
var autobahn = require(&#x27;autobahn&#x27;);

var connection = new autobahn.<span class="apidocCodeKeywordSpan">Connection</span>({url: &#x27;ws://127.0.0.1:9000/&#x27;, realm
: &#x27;realm1&#x27;});

connection.onopen = function (session) {

// 1) subscribe to a topic
function onevent(args) {
   console.log(&#x22;Event:&#x22;, args[0]);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.log" id="apidoc.module.autobahn.log">module autobahn.log</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.log.debug" id="apidoc.element.autobahn.log.debug">
        function <span class="apidocSignatureSpan">autobahn.log.</span>debug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debug = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            deferred.reject = reject;
         });

         return deferred;
      };
   } else {

      log.<span class="apidocCodeKeywordSpan">debug</span>(&#x22;Warning: ES6 promises requested, but not found! Falling back to
 whenjs.&#x22;);

      // whenjs-based deferred factory
      //
      self._defer = when.defer;
   }

} else if (options &#x26;&#x26; options.use_deferred) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.log.warn" id="apidoc.element.autobahn.log.warn">
        function <span class="apidocSignatureSpan">autobahn.log.</span>warn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warn = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         var transport = transport_factory.create();
         if (transport) {
            log.debug(&#x22;using WAMP transport type: &#x22; + transport_factory.type);
            return transport;
         }
      } catch (e) {
         // ignore
         log.<span class="apidocCodeKeywordSpan">warn</span>(&#x22;could not create WAMP transport &#x27;&#x22; + transport_factory
.type + &#x22;&#x27;: &#x22; + e);
      }
   }

   log.warn(&#x27;could not create any WAMP transport&#x27;);
   return null;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.longpoll" id="apidoc.module.autobahn.longpoll">module autobahn.longpoll</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.longpoll.Factory" id="apidoc.element.autobahn.longpoll.Factory">
        function <span class="apidocSignatureSpan">autobahn.longpoll.</span>Factory
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Factory(options) {
   var self = this;

   util.assert(options.url !== undefined, &#x22;options.url missing&#x22;);
   util.assert(typeof options.url === &#x22;string&#x22;, &#x22;options.url must be a string&#x22;);

   self._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.msgpack" id="apidoc.module.autobahn.msgpack">module autobahn.msgpack</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder" id="apidoc.element.autobahn.msgpack.Decoder">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>Decoder
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decoder(options) {
  if (!(this instanceof Decoder)) return new Decoder(options);
  DecodeBuffer.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Encoder" id="apidoc.element.autobahn.msgpack.Encoder">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>Encoder
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Encoder(options) {
  if (!(this instanceof Encoder)) return new Encoder(options);
  EncodeBuffer.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createCodec" id="apidoc.element.autobahn.msgpack.createCodec">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createCodec
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCodec(options) {
  return new Codec(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// this is needed for correct msgpack serialization of WAMP session IDs
var Uint64BE = require(&#x27;int64-buffer&#x27;).Uint64BE;

function MsgpackSerializer() {
this.SERIALIZER_ID = &#x27;msgpack&#x27;;
this.BINARY = true;
this.codec = msgpack.<span class="apidocCodeKeywordSpan">createCodec</span>();

// msgpack: Uint64BE ensures that ID is encoded as int instead of double
this.newid = function () { return new Uint64BE(newid()); };
}

MsgpackSerializer.prototype.serialize = function (obj) {
try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createDecodeStream" id="apidoc.element.autobahn.msgpack.createDecodeStream">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createDecodeStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DecodeStream(options) {
  if (!(this instanceof DecodeStream)) return new DecodeStream(options);
  if (options) {
    options.objectMode = true;
  } else {
    options = DEFAULT_OPTIONS;
  }
  Transform.call(this, options);
  var stream = this;
  var decoder = this.decoder = new DecodeBuffer(options);
  decoder.push = function(chunk) {
    stream.push(chunk);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createEncodeStream" id="apidoc.element.autobahn.msgpack.createEncodeStream">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createEncodeStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EncodeStream(options) {
  if (!(this instanceof EncodeStream)) return new EncodeStream(options);
  if (options) {
    options.objectMode = true;
  } else {
    options = DEFAULT_OPTIONS;
  }
  Transform.call(this, options);

  var stream = this;
  var encoder = this.encoder = new EncodeBuffer(options);
  encoder.push = function(chunk) {
    stream.push(chunk);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.decode" id="apidoc.element.autobahn.msgpack.decode">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>decode
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode(input, options) {
  var decoder = new DecodeBuffer(options);
  decoder.write(input);
  return decoder.read();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
};

MsgpackSerializer.prototype.unserialize = function (payload) {
   try {
      // need to encapsulate ArrayBuffer into Uint8Array for msgpack decoding
      // https://github.com/kawanet/msgpack-lite/issues/44
      var obj = msgpack.<span class="apidocCodeKeywordSpan">decode</span>(new Uint8Array(payload), {codec: this.codec});
      return obj;
   } catch (e) {
      log.warn(&#x27;MessagePack decoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.encode" id="apidoc.element.autobahn.msgpack.encode">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>encode
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode(input, options) {
  var encoder = new EncodeBuffer(options);
  encoder.write(input);
  return encoder.read();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   // msgpack: Uint64BE ensures that ID is encoded as int instead of double
   this.newid = function () { return new Uint64BE(newid()); };
}

MsgpackSerializer.prototype.serialize = function (obj) {
   try {
      var payload = msgpack.<span class="apidocCodeKeywordSpan">encode</span>(obj, {codec: this.codec});
      return payload;
   } catch (e) {
      log.warn(&#x27;MessagePack encoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.msgpack.Decoder" id="apidoc.module.autobahn.msgpack.Decoder">module autobahn.msgpack.Decoder</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder.Decoder" id="apidoc.element.autobahn.msgpack.Decoder.Decoder">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>Decoder
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decoder(options) {
  if (!(this instanceof Decoder)) return new Decoder(options);
  DecodeBuffer.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.msgpack.Decoder.prototype" id="apidoc.module.autobahn.msgpack.Decoder.prototype">module autobahn.msgpack.Decoder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder.prototype.decode" id="apidoc.element.autobahn.msgpack.Decoder.prototype.decode">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>decode
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (chunk) {
  if (arguments.length) this.write(chunk);
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
};

MsgpackSerializer.prototype.unserialize = function (payload) {
   try {
      // need to encapsulate ArrayBuffer into Uint8Array for msgpack decoding
      // https://github.com/kawanet/msgpack-lite/issues/44
      var obj = msgpack.<span class="apidocCodeKeywordSpan">decode</span>(new Uint8Array(payload), {codec: this.codec});
      return obj;
   } catch (e) {
      log.warn(&#x27;MessagePack decoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder.prototype.emit" id="apidoc.element.autobahn.msgpack.Decoder.prototype.emit">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>emit
        <span class="apidocSignatureSpan">(type, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type, value) {
  var that = this;
  var listeners = getListeners(that, type, true);
  if (!listeners) return false;
  var arglen = arguments.length;
  if (arglen === 1) {
    listeners.forEach(zeroarg);
  } else if (arglen === 2) {
    listeners.forEach(onearg);
  } else {
    var args = Array.prototype.slice.call(arguments, 1);
    listeners.forEach(moreargs);
  }
  return !!listeners.length;

  function zeroarg(func) {
    func.call(that);
  }

  function onearg(func) {
    func.call(that, value);
  }

  function moreargs(func) {
    func.apply(that, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      testcase.expect(3);

      var machine = new StateMachine({
// Mock connection opening and wait for handshake
init: function () {
   this.transition(&#x27;waitForHandshake&#x27;);
   wire.rx.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;connect&#x27;);
},

// Check handshake packet validity
waitForHandshake: function (handshake) {
   testcase.equal(handshake.length, 4, &#x27;Handshake should be 4 bytes&#x27;);
   testcase.equal(handshake[0], 0x7f, &#x27;Magic byte must be 0x7f&#x27;);
   testcase.ok([ 0x1, 0x2 ].indexOf(handshake[1] &#x26; 0xf) &#x3e; -1, &#x27;Must announce a valid serializer&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder.prototype.end" id="apidoc.element.autobahn.msgpack.Decoder.prototype.end">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk) {
  this.decode(chunk);
  this.emit(&#x22;end&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Close transport
*
* @returns {Integer} Closed state code
*/
Protocol.prototype.close = function () {
  this._status = this.STATUS.CLOSED;
  this._stream.<span class="apidocCodeKeywordSpan">end</span>();

  return this.STATUS.CLOSED;
};

/**
* Write a frame to the transport
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder.prototype.off" id="apidoc.element.autobahn.msgpack.Decoder.prototype.off">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>off
        <span class="apidocSignatureSpan">(type, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function off(type, func) {
  var that = this;
  var listners;
  if (!arguments.length) {
    delete that[LISTENERS];
  } else if (!func) {
    listners = that[LISTENERS];
    if (listners) {
      delete listners[type];
      if (!Object.keys(listners).length) return off.call(that);
    }
  } else {
    listners = getListeners(that, type, true);
    if (listners) {
      listners = listners.filter(ne);
      if (!listners.length) return off.call(that, type);
      that[LISTENERS][type] = listners;
    }
  }
  return that;

  function ne(test) {
    return test !== func &#x26;&#x26; test.originalListener !== func;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder.prototype.on" id="apidoc.element.autobahn.msgpack.Decoder.prototype.on">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>on
        <span class="apidocSignatureSpan">(type, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(type, func) {
  getListeners(this, type).push(func);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   wait: function () {},
});

// Init the protocol
var protocol = new rawsocket.Protocol(wire.rx);

// When data is received by the tx wire, send it to the state machine
wire.tx.<span class="apidocCodeKeywordSpan">on</span>(&#x27;data&#x27;, function (data) {
   machine.tick(data);
});

// Ensure we don&#x27;t throw
// Ensure we don&#x27;t throw
protocol.on(&#x27;error&#x27;, function (err) {
   testcase.ok(false, &#x27;Should not throw a protocol error&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder.prototype.once" id="apidoc.element.autobahn.msgpack.Decoder.prototype.once">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>once
        <span class="apidocSignatureSpan">(type, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, func) {
  var that = this;
  wrap.originalListener = func;
  getListeners(that, type).push(wrap);
  return that;

  function wrap() {
    off.call(that, type, wrap);
    func.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Protocol.prototype.on = function (evt, handler) {
   return this._emitter.on(evt, handler);
};

Protocol.prototype.once = function (evt, handler) {
   return this._emitter.<span class="apidocCodeKeywordSpan">once</span>(evt, handler);
};

Protocol.prototype.removeListener = function (evt, handler) {
   return this._emitter.removeListener(evt, handler);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Decoder.prototype.push" id="apidoc.element.autobahn.msgpack.Decoder.prototype.push">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Decoder.prototype.</span>push
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (chunk) {
  this.emit(&#x22;data&#x22;, chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
}


Transports.prototype.list = function() {
   var items = [];
   for (var name in this._repository) {
      items.<span class="apidocCodeKeywordSpan">push</span>(name);
   }
   return items;
};


var _transports = new Transports();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.msgpack.Encoder" id="apidoc.module.autobahn.msgpack.Encoder">module autobahn.msgpack.Encoder</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Encoder.Encoder" id="apidoc.element.autobahn.msgpack.Encoder.Encoder">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>Encoder
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Encoder(options) {
  if (!(this instanceof Encoder)) return new Encoder(options);
  EncodeBuffer.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.msgpack.Encoder.prototype" id="apidoc.module.autobahn.msgpack.Encoder.prototype">module autobahn.msgpack.Encoder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Encoder.prototype.emit" id="apidoc.element.autobahn.msgpack.Encoder.prototype.emit">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>emit
        <span class="apidocSignatureSpan">(type, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type, value) {
  var that = this;
  var listeners = getListeners(that, type, true);
  if (!listeners) return false;
  var arglen = arguments.length;
  if (arglen === 1) {
    listeners.forEach(zeroarg);
  } else if (arglen === 2) {
    listeners.forEach(onearg);
  } else {
    var args = Array.prototype.slice.call(arguments, 1);
    listeners.forEach(moreargs);
  }
  return !!listeners.length;

  function zeroarg(func) {
    func.call(that);
  }

  function onearg(func) {
    func.call(that, value);
  }

  function moreargs(func) {
    func.apply(that, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      testcase.expect(3);

      var machine = new StateMachine({
// Mock connection opening and wait for handshake
init: function () {
   this.transition(&#x27;waitForHandshake&#x27;);
   wire.rx.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;connect&#x27;);
},

// Check handshake packet validity
waitForHandshake: function (handshake) {
   testcase.equal(handshake.length, 4, &#x27;Handshake should be 4 bytes&#x27;);
   testcase.equal(handshake[0], 0x7f, &#x27;Magic byte must be 0x7f&#x27;);
   testcase.ok([ 0x1, 0x2 ].indexOf(handshake[1] &#x26; 0xf) &#x3e; -1, &#x27;Must announce a valid serializer&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Encoder.prototype.encode" id="apidoc.element.autobahn.msgpack.Encoder.prototype.encode">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>encode
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (chunk) {
  this.write(chunk);
  this.emit(&#x22;data&#x22;, this.read());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   // msgpack: Uint64BE ensures that ID is encoded as int instead of double
   this.newid = function () { return new Uint64BE(newid()); };
}

MsgpackSerializer.prototype.serialize = function (obj) {
   try {
      var payload = msgpack.<span class="apidocCodeKeywordSpan">encode</span>(obj, {codec: this.codec});
      return payload;
   } catch (e) {
      log.warn(&#x27;MessagePack encoding error&#x27;, e);
      throw e;
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Encoder.prototype.end" id="apidoc.element.autobahn.msgpack.Encoder.prototype.end">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk) {
  if (arguments.length) this.encode(chunk);
  this.flush();
  this.emit(&#x22;end&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Close transport
*
* @returns {Integer} Closed state code
*/
Protocol.prototype.close = function () {
  this._status = this.STATUS.CLOSED;
  this._stream.<span class="apidocCodeKeywordSpan">end</span>();

  return this.STATUS.CLOSED;
};

/**
* Write a frame to the transport
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Encoder.prototype.off" id="apidoc.element.autobahn.msgpack.Encoder.prototype.off">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>off
        <span class="apidocSignatureSpan">(type, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function off(type, func) {
  var that = this;
  var listners;
  if (!arguments.length) {
    delete that[LISTENERS];
  } else if (!func) {
    listners = that[LISTENERS];
    if (listners) {
      delete listners[type];
      if (!Object.keys(listners).length) return off.call(that);
    }
  } else {
    listners = getListeners(that, type, true);
    if (listners) {
      listners = listners.filter(ne);
      if (!listners.length) return off.call(that, type);
      that[LISTENERS][type] = listners;
    }
  }
  return that;

  function ne(test) {
    return test !== func &#x26;&#x26; test.originalListener !== func;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Encoder.prototype.on" id="apidoc.element.autobahn.msgpack.Encoder.prototype.on">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>on
        <span class="apidocSignatureSpan">(type, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(type, func) {
  getListeners(this, type).push(func);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   wait: function () {},
});

// Init the protocol
var protocol = new rawsocket.Protocol(wire.rx);

// When data is received by the tx wire, send it to the state machine
wire.tx.<span class="apidocCodeKeywordSpan">on</span>(&#x27;data&#x27;, function (data) {
   machine.tick(data);
});

// Ensure we don&#x27;t throw
// Ensure we don&#x27;t throw
protocol.on(&#x27;error&#x27;, function (err) {
   testcase.ok(false, &#x27;Should not throw a protocol error&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.Encoder.prototype.once" id="apidoc.element.autobahn.msgpack.Encoder.prototype.once">
        function <span class="apidocSignatureSpan">autobahn.msgpack.Encoder.prototype.</span>once
        <span class="apidocSignatureSpan">(type, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, func) {
  var that = this;
  wrap.originalListener = func;
  getListeners(that, type).push(wrap);
  return that;

  function wrap() {
    off.call(that, type, wrap);
    func.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Protocol.prototype.on = function (evt, handler) {
   return this._emitter.on(evt, handler);
};

Protocol.prototype.once = function (evt, handler) {
   return this._emitter.<span class="apidocCodeKeywordSpan">once</span>(evt, handler);
};

Protocol.prototype.removeListener = function (evt, handler) {
   return this._emitter.removeListener(evt, handler);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.msgpack.createDecodeStream" id="apidoc.module.autobahn.msgpack.createDecodeStream">module autobahn.msgpack.createDecodeStream</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createDecodeStream.createDecodeStream" id="apidoc.element.autobahn.msgpack.createDecodeStream.createDecodeStream">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createDecodeStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DecodeStream(options) {
  if (!(this instanceof DecodeStream)) return new DecodeStream(options);
  if (options) {
    options.objectMode = true;
  } else {
    options = DEFAULT_OPTIONS;
  }
  Transform.call(this, options);
  var stream = this;
  var decoder = this.decoder = new DecodeBuffer(options);
  decoder.push = function(chunk) {
    stream.push(chunk);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createDecodeStream.super_" id="apidoc.element.autobahn.msgpack.createDecodeStream.super_">
        function <span class="apidocSignatureSpan">autobahn.msgpack.createDecodeStream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === &#x27;function&#x27;)
      this._transform = options.transform;

    if (typeof options.flush === &#x27;function&#x27;)
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once(&#x27;prefinish&#x27;, function() {
    if (typeof this._flush === &#x27;function&#x27;)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.msgpack.createDecodeStream.prototype" id="apidoc.module.autobahn.msgpack.createDecodeStream.prototype">module autobahn.msgpack.createDecodeStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createDecodeStream.prototype._transform" id="apidoc.element.autobahn.msgpack.createDecodeStream.prototype._transform">
        function <span class="apidocSignatureSpan">autobahn.msgpack.createDecodeStream.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  this.decoder.write(chunk);
  this.decoder.flush();
  if (callback) callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.msgpack.createEncodeStream" id="apidoc.module.autobahn.msgpack.createEncodeStream">module autobahn.msgpack.createEncodeStream</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createEncodeStream.createEncodeStream" id="apidoc.element.autobahn.msgpack.createEncodeStream.createEncodeStream">
        function <span class="apidocSignatureSpan">autobahn.msgpack.</span>createEncodeStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EncodeStream(options) {
  if (!(this instanceof EncodeStream)) return new EncodeStream(options);
  if (options) {
    options.objectMode = true;
  } else {
    options = DEFAULT_OPTIONS;
  }
  Transform.call(this, options);

  var stream = this;
  var encoder = this.encoder = new EncodeBuffer(options);
  encoder.push = function(chunk) {
    stream.push(chunk);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createEncodeStream.super_" id="apidoc.element.autobahn.msgpack.createEncodeStream.super_">
        function <span class="apidocSignatureSpan">autobahn.msgpack.createEncodeStream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === &#x27;function&#x27;)
      this._transform = options.transform;

    if (typeof options.flush === &#x27;function&#x27;)
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once(&#x27;prefinish&#x27;, function() {
    if (typeof this._flush === &#x27;function&#x27;)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.msgpack.createEncodeStream.prototype" id="apidoc.module.autobahn.msgpack.createEncodeStream.prototype">module autobahn.msgpack.createEncodeStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createEncodeStream.prototype._flush" id="apidoc.element.autobahn.msgpack.createEncodeStream.prototype._flush">
        function <span class="apidocSignatureSpan">autobahn.msgpack.createEncodeStream.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  this.encoder.flush();
  if (callback) callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.msgpack.createEncodeStream.prototype._transform" id="apidoc.element.autobahn.msgpack.createEncodeStream.prototype._transform">
        function <span class="apidocSignatureSpan">autobahn.msgpack.createEncodeStream.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  this.encoder.write(chunk);
  if (callback) callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.persona" id="apidoc.module.autobahn.persona">module autobahn.persona</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.persona.auth" id="apidoc.element.autobahn.persona.auth">
        function <span class="apidocSignatureSpan">autobahn.persona.</span>auth
        <span class="apidocSignatureSpan">(session, user, extra)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auth(session, user, extra) {

   // Persona Issues:
   //
   // Chrome: https://github.com/mozilla/persona/issues/4083
   // IE11: https://groups.google.com/forum/#!topic/mozilla.dev.identity/keEkVpvfLA8

   var d = session.defer();

   navigator.id.watch({
      loggedInUser: user,
      onlogin: function (assertion) {
         // A user has logged in! Here you need to:
         // 1. Send the assertion to your backend for verification and to create a session.
         // 2. Update your UI.
         d.resolve(assertion);
      },
      onlogout: function() {
         // A user has logged out! Here you need to:
         // Tear down the user&#x27;s session by redirecting the user or making a call to your backend.
         // Also, make sure loggedInUser will get set to null on the next page load.
         // (That&#x27;s a literal JavaScript null. Not false, 0, or undefined. null.)
         session.leave(&#x22;wamp.close.logout&#x22;);
      }
   });

   if (d.promise.then) {
      // whenjs has the actual user promise in an attribute
      return d.promise;
   } else {
      return d;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.rawsocket" id="apidoc.module.autobahn.rawsocket">module autobahn.rawsocket</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.rawsocket.Factory" id="apidoc.element.autobahn.rawsocket.Factory">
        function <span class="apidocSignatureSpan">autobahn.rawsocket.</span>Factory
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Factory(options) {
   var self = this;

   if (!options.protocols) {
      options.protocols = [&#x27;wamp.2.json&#x27;];
   } else {
      util.assert(Array.isArray(options.protocols), &#x22;options.protocols must be an array&#x22;);
   }

   options.rawsocket_max_len_exp = options.rawsocket_max_len_exp || 24;

   self._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.rawsocket.Protocol" id="apidoc.element.autobahn.rawsocket.Protocol">
        function <span class="apidocSignatureSpan">autobahn.rawsocket.</span>Protocol
        <span class="apidocSignatureSpan">(stream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Protocol(stream, options) {
   this._options = {
      _peer_serializer: null, // Will hold the serializer declared by the peer
      _peer_max_len_exp: 0    // Will hold the maximum frame length declared by
                              // the peer
   };

   this._options = util.defaults(this._options, options, this.DEFAULT_OPTIONS);

   // Check valid options
   util.assert(this._options.serializer in this.SERIALIZERS,
      &#x27;Unsupported serializer: &#x27; + this._options.serializer);

   util.assert(this._options.max_len_exp &#x3e;= 9 &#x26;&#x26;
      this._options.max_len_exp &#x3c;= 36,
      &#x27;Message length out of bounds [9, 36]: &#x27;+ this._options.max_len_exp);

   util.assert(!this._options.autoping ||
      (Number.isInteger(this._options.autoping) &#x26;&#x26; this._options.autoping &#x3e;= 0),
      &#x27;Autoping interval must be positive&#x27;);

   util.assert(!this._options.ping_timeout ||
      (Number.isInteger(this._options.ping_timeout) &#x26;&#x26;
         this._options.ping_timeout &#x3e;= 0),
      &#x27;Ping timeout duration must be positive&#x27;);

   util.assert(!this._options.packet_timeout ||
      (Number.isInteger(this._options.packet_timeout) &#x26;&#x26;
         this._options.packet_timeout &#x3e;= 0),
      &#x27;Packet timeout duration must be positive&#x27;);

   util.assert((!this._options.autoping || !this._options.ping_timeout) ||
      this._options.autoping &#x3e; this._options.ping_timeout,
      &#x27;Autoping interval (&#x27; + this._options.autoping + &#x27;) must be lower &#x27; +
      &#x27;than ping timeout (&#x27; + this._options.ping_timeout + &#x27;)&#x27;);

   // Will store a reference to the timeout function associated with the last
   // PING packet
   this._ping_timeout = null;

   // Will store the payload of the last PING packet
   this._ping_payload = null;

   // Will store the autoping setInterval reference
   this._ping_interval = null;

   // Protocol status (see Protocol.prototype.STATUS)
   this._status = this.STATUS.UNINITIATED;

   this._stream = stream;
   this._emitter = new EventEmitter();

   // Frame buffer
   this._buffer = new Buffer(4);
   this._bufferLen = 0;
   this._msgLen = 0;

   // Hook events
   var self = this;
   this._stream.on(&#x27;data&#x27;, function (data) {
      self._read(data);
   });

   this._stream.on(&#x27;connect&#x27;, function () {
      self._handshake();
   });

   // Proxy these events from the stream as we don&#x27;t need to handle them
   var proxyEvents = [
      &#x27;close&#x27;,
      &#x27;drain&#x27;,
      &#x27;end&#x27;,
      &#x27;error&#x27;,
      &#x27;timeout&#x27;
   ];
   proxyEvents.forEach(function (evt) {
      self._stream.on(evt, function (data) {
         self._emitter.emit(evt, data);
      });
   });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         testcase.done();
      }, 50);
   },
   wait: function () {},
});

// Init the protocol
var protocol = new rawsocket.<span class="apidocCodeKeywordSpan">Protocol</span>(wire.rx);

// When data is received by the tx wire, send it to the state machine
wire.tx.on(&#x27;data&#x27;, function (data) {
   machine.tick(data);
});

// Ensure we don&#x27;t throw
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.rawsocket.ProtocolError" id="apidoc.element.autobahn.rawsocket.ProtocolError">
        function <span class="apidocSignatureSpan">autobahn.rawsocket.</span>ProtocolError
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ProtocolError = function (msg) {
   Error.apply(this, Array.prototype.splice.call(arguments));

   Error.captureStackTrace(this, this.constructor);

   this.message = msg;
   this.name = &#x27;ProtocolError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.serializer" id="apidoc.module.autobahn.serializer">module autobahn.serializer</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.serializer.CBORSerializer" id="apidoc.element.autobahn.serializer.CBORSerializer">
        function <span class="apidocSignatureSpan">autobahn.serializer.</span>CBORSerializer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CBORSerializer() {
   this.SERIALIZER_ID = &#x27;cbor&#x27;;
   this.BINARY = true;

   // CBOR encoder does not need anything special here
   this.newid = newid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.testCBORSerialization = function (testcase) {

testcase.expect(1);

var test = new testutil.Testlog(&#x22;test/test_serialization_cbor.txt&#x22;);

var ser = new autobahn.serializer.<span class="apidocCodeKeywordSpan">CBORSerializer</span>();

var config = {
   url: testutil.config.url,
   realm: testutil.config.realm,
   serializers: [ser]
};
var connection = new autobahn.Connection(config);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.serializer.JSONSerializer" id="apidoc.element.autobahn.serializer.JSONSerializer">
        function <span class="apidocSignatureSpan">autobahn.serializer.</span>JSONSerializer
        <span class="apidocSignatureSpan">(replacer, reviver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONSerializer(replacer, reviver) {
   this.replacer = replacer;
   this.reviver = reviver;
   this.SERIALIZER_ID = &#x27;json&#x27;;
   this.BINARY = false;

   // JSON encoder does not need anything special here
   this.newid = newid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.testJSONSerialization = function (testcase) {

testcase.expect(1);

var test = new testutil.Testlog(&#x22;test/test_serialization_json.txt&#x22;);

var ser = new autobahn.serializer.<span class="apidocCodeKeywordSpan">JSONSerializer</span>();

var config = {
   url: testutil.config.url,
   realm: testutil.config.realm,
   serializers: [ser]
};
var connection = new autobahn.Connection(config);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.serializer.MsgpackSerializer" id="apidoc.element.autobahn.serializer.MsgpackSerializer">
        function <span class="apidocSignatureSpan">autobahn.serializer.</span>MsgpackSerializer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MsgpackSerializer() {
   this.SERIALIZER_ID = &#x27;msgpack&#x27;;
   this.BINARY = true;
   this.codec = msgpack.createCodec();

   // msgpack: Uint64BE ensures that ID is encoded as int instead of double
   this.newid = function () { return new Uint64BE(newid()); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         type: &#x27;rawsocket&#x27;,
         host: &#x27;127.0.0.1&#x27;,
         port: 8080
      }
   ],
   // FIXME - serializer is ignored! sth wrong
   serializers: [
      new autobahn.serializer.<span class="apidocCodeKeywordSpan">MsgpackSerializer</span>()
   ],
   protocols: [&#x27;wamp.2.msgpack&#x27;]
};

var dl = testutil.connect_n(N, connection_config);

autobahn.when.all(dl).then(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.serializer.CBORSerializer" id="apidoc.module.autobahn.serializer.CBORSerializer">module autobahn.serializer.CBORSerializer</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.serializer.CBORSerializer.CBORSerializer" id="apidoc.element.autobahn.serializer.CBORSerializer.CBORSerializer">
        function <span class="apidocSignatureSpan">autobahn.serializer.</span>CBORSerializer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CBORSerializer() {
   this.SERIALIZER_ID = &#x27;cbor&#x27;;
   this.BINARY = true;

   // CBOR encoder does not need anything special here
   this.newid = newid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.testCBORSerialization = function (testcase) {

testcase.expect(1);

var test = new testutil.Testlog(&#x22;test/test_serialization_cbor.txt&#x22;);

var ser = new autobahn.serializer.<span class="apidocCodeKeywordSpan">CBORSerializer</span>();

var config = {
   url: testutil.config.url,
   realm: testutil.config.realm,
   serializers: [ser]
};
var connection = new autobahn.Connection(config);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.serializer.CBORSerializer.prototype" id="apidoc.module.autobahn.serializer.CBORSerializer.prototype">module autobahn.serializer.CBORSerializer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.serializer.CBORSerializer.prototype.serialize" id="apidoc.element.autobahn.serializer.CBORSerializer.prototype.serialize">
        function <span class="apidocSignatureSpan">autobahn.serializer.CBORSerializer.prototype.</span>serialize
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function (obj) {
   try {
      var payload = cbor.encode(obj);
      return payload;
   } catch (e) {
      log.warn(&#x27;CBOR encoding error&#x27;, e);
      throw e;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
   websocket = new WebSocket(self._options.url, {protocol: protocols});
} else {
   websocket = new WebSocket(self._options.url);
}

transport.send = function (msg) {
   var payload = transport.serializer.<span class="apidocCodeKeywordSpan">serialize</span>(msg);
   websocket.send(payload, {binary: transport.serializer.BINARY});
};

transport.close = function (code, reason) {
   websocket.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.serializer.CBORSerializer.prototype.unserialize" id="apidoc.element.autobahn.serializer.CBORSerializer.prototype.unserialize">
        function <span class="apidocSignatureSpan">autobahn.serializer.CBORSerializer.prototype.</span>unserialize
        <span class="apidocSignatureSpan">(payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unserialize = function (payload) {
   try {
      //var obj = cbor.decodeAllSync(payload)[0];
      var obj = cbor.decodeFirstSync(payload);
      return obj;
   } catch (e) {
      log.warn(&#x27;CBOR decoding error&#x27;, e);
      throw e;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }

   transport.info.protocol = websocket.protocol;
   transport.onopen();
});

websocket.on(&#x27;message&#x27;, function (data, flags) {
   var msg = transport.serializer.<span class="apidocCodeKeywordSpan">unserialize</span>(data);
   transport.onmessage(msg);
});

// FIXME: improve mapping to WS API for the following
// https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Close_codes
//
websocket.on(&#x27;close&#x27;, function (code, message) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.serializer.JSONSerializer" id="apidoc.module.autobahn.serializer.JSONSerializer">module autobahn.serializer.JSONSerializer</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.serializer.JSONSerializer.JSONSerializer" id="apidoc.element.autobahn.serializer.JSONSerializer.JSONSerializer">
        function <span class="apidocSignatureSpan">autobahn.serializer.</span>JSONSerializer
        <span class="apidocSignatureSpan">(replacer, reviver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONSerializer(replacer, reviver) {
   this.replacer = replacer;
   this.reviver = reviver;
   this.SERIALIZER_ID = &#x27;json&#x27;;
   this.BINARY = false;

   // JSON encoder does not need anything special here
   this.newid = newid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.testJSONSerialization = function (testcase) {

testcase.expect(1);

var test = new testutil.Testlog(&#x22;test/test_serialization_json.txt&#x22;);

var ser = new autobahn.serializer.<span class="apidocCodeKeywordSpan">JSONSerializer</span>();

var config = {
   url: testutil.config.url,
   realm: testutil.config.realm,
   serializers: [ser]
};
var connection = new autobahn.Connection(config);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.serializer.JSONSerializer.prototype" id="apidoc.module.autobahn.serializer.JSONSerializer.prototype">module autobahn.serializer.JSONSerializer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.serializer.JSONSerializer.prototype.serialize" id="apidoc.element.autobahn.serializer.JSONSerializer.prototype.serialize">
        function <span class="apidocSignatureSpan">autobahn.serializer.JSONSerializer.prototype.</span>serialize
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function (obj) {
   try {
      var payload = JSON.stringify(obj, this.replacer);
      return payload;
   } catch (e) {
      log.warn(&#x27;JSON encoding error&#x27;, e);
      throw e;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
   websocket = new WebSocket(self._options.url, {protocol: protocols});
} else {
   websocket = new WebSocket(self._options.url);
}

transport.send = function (msg) {
   var payload = transport.serializer.<span class="apidocCodeKeywordSpan">serialize</span>(msg);
   websocket.send(payload, {binary: transport.serializer.BINARY});
};

transport.close = function (code, reason) {
   websocket.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.serializer.JSONSerializer.prototype.unserialize" id="apidoc.element.autobahn.serializer.JSONSerializer.prototype.unserialize">
        function <span class="apidocSignatureSpan">autobahn.serializer.JSONSerializer.prototype.</span>unserialize
        <span class="apidocSignatureSpan">(payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unserialize = function (payload) {
   try {
      var obj = JSON.parse(payload, this.reviver);
      return obj;
   } catch (e) {
      log.warn(&#x27;JSON decoding error&#x27;, e);
      throw e;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }

   transport.info.protocol = websocket.protocol;
   transport.onopen();
});

websocket.on(&#x27;message&#x27;, function (data, flags) {
   var msg = transport.serializer.<span class="apidocCodeKeywordSpan">unserialize</span>(data);
   transport.onmessage(msg);
});

// FIXME: improve mapping to WS API for the following
// https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Close_codes
//
websocket.on(&#x27;close&#x27;, function (code, message) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.serializer.MsgpackSerializer" id="apidoc.module.autobahn.serializer.MsgpackSerializer">module autobahn.serializer.MsgpackSerializer</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.serializer.MsgpackSerializer.MsgpackSerializer" id="apidoc.element.autobahn.serializer.MsgpackSerializer.MsgpackSerializer">
        function <span class="apidocSignatureSpan">autobahn.serializer.</span>MsgpackSerializer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MsgpackSerializer() {
   this.SERIALIZER_ID = &#x27;msgpack&#x27;;
   this.BINARY = true;
   this.codec = msgpack.createCodec();

   // msgpack: Uint64BE ensures that ID is encoded as int instead of double
   this.newid = function () { return new Uint64BE(newid()); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         type: &#x27;rawsocket&#x27;,
         host: &#x27;127.0.0.1&#x27;,
         port: 8080
      }
   ],
   // FIXME - serializer is ignored! sth wrong
   serializers: [
      new autobahn.serializer.<span class="apidocCodeKeywordSpan">MsgpackSerializer</span>()
   ],
   protocols: [&#x27;wamp.2.msgpack&#x27;]
};

var dl = testutil.connect_n(N, connection_config);

autobahn.when.all(dl).then(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.serializer.MsgpackSerializer.prototype" id="apidoc.module.autobahn.serializer.MsgpackSerializer.prototype">module autobahn.serializer.MsgpackSerializer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.serializer.MsgpackSerializer.prototype.registerExtType" id="apidoc.element.autobahn.serializer.MsgpackSerializer.prototype.registerExtType">
        function <span class="apidocSignatureSpan">autobahn.serializer.MsgpackSerializer.prototype.</span>registerExtType
        <span class="apidocSignatureSpan">(code, type, packer, unpacker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerExtType = function (code, type, packer, unpacker) {
   if (packer &#x26;&#x26; type) {
      this.codec.addExtPacker(code, type, packer);
   }
   if (unpacker) {
      this.codec.addExtUnpacker(code, unpacker);
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.serializer.MsgpackSerializer.prototype.serialize" id="apidoc.element.autobahn.serializer.MsgpackSerializer.prototype.serialize">
        function <span class="apidocSignatureSpan">autobahn.serializer.MsgpackSerializer.prototype.</span>serialize
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function (obj) {
   try {
      var payload = msgpack.encode(obj, {codec: this.codec});
      return payload;
   } catch (e) {
      log.warn(&#x27;MessagePack encoding error&#x27;, e);
      throw e;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
   websocket = new WebSocket(self._options.url, {protocol: protocols});
} else {
   websocket = new WebSocket(self._options.url);
}

transport.send = function (msg) {
   var payload = transport.serializer.<span class="apidocCodeKeywordSpan">serialize</span>(msg);
   websocket.send(payload, {binary: transport.serializer.BINARY});
};

transport.close = function (code, reason) {
   websocket.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.serializer.MsgpackSerializer.prototype.unserialize" id="apidoc.element.autobahn.serializer.MsgpackSerializer.prototype.unserialize">
        function <span class="apidocSignatureSpan">autobahn.serializer.MsgpackSerializer.prototype.</span>unserialize
        <span class="apidocSignatureSpan">(payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unserialize = function (payload) {
   try {
      // need to encapsulate ArrayBuffer into Uint8Array for msgpack decoding
      // https://github.com/kawanet/msgpack-lite/issues/44
      var obj = msgpack.decode(new Uint8Array(payload), {codec: this.codec});
      return obj;
   } catch (e) {
      log.warn(&#x27;MessagePack decoding error&#x27;, e);
      throw e;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }

   transport.info.protocol = websocket.protocol;
   transport.onopen();
});

websocket.on(&#x27;message&#x27;, function (data, flags) {
   var msg = transport.serializer.<span class="apidocCodeKeywordSpan">unserialize</span>(data);
   transport.onmessage(msg);
});

// FIXME: improve mapping to WS API for the following
// https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Close_codes
//
websocket.on(&#x27;close&#x27;, function (code, message) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.session" id="apidoc.module.autobahn.session">module autobahn.session</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.session.Error" id="apidoc.element.autobahn.session.Error">
        function <span class="apidocSignatureSpan">autobahn.session.</span>Error
        <span class="apidocSignatureSpan">(error, args, kwargs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error = function (error, args, kwargs) {

   var self = this;

   self.error = error;
   self.args = args || [];
   self.kwargs = kwargs || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
logging this in the caller will come out something like

    wamp.error.runtime_error [&#x22;this is just an error&#x22;, &#x22;with an array of arguments&#x22;] Object {}

When defining an `autobahn.Error` object, all three properties can be defined. I.e. doing

``` js
throw new autobahn.<span class="apidocCodeKeywordSpan">Error</span>(&#x27;com.myapp.error&#x27;, [&#x27;this is a more complex error
&#x27;], {a: 23, b: 9});
```

and logging this in the caller will lead to something like

    com.myapp.error [&#x27;this is a more complex error&#x27;] Object {a: 23, b: 9}

Complete Examples:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.session.Event" id="apidoc.element.autobahn.session.Event">
        function <span class="apidocSignatureSpan">autobahn.session.</span>Event
        <span class="apidocSignatureSpan">(publication, topic, publisher, publisher_authid, publisher_authrole)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Event = function (publication, topic, publisher, publisher_authid, publisher_authrole) {

   var self = this;

   self.publication = publication;
   self.topic = topic;
   self.publisher = publisher;
   self.publisher_authid = publisher_authid;
   self.publisher_authrole = publisher_authrole;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.session.Invocation" id="apidoc.element.autobahn.session.Invocation">
        function <span class="apidocSignatureSpan">autobahn.session.</span>Invocation
        <span class="apidocSignatureSpan">(procedure, progress, caller, caller_authid, caller_authrole)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Invocation = function (procedure, progress, caller, caller_authid, caller_authrole) {

   var self = this;

   self.procedure = procedure;
   self.progress = progress;
   self.caller = caller;
   self.caller_authid = caller_authid;
   self.caller_authrole = caller_authrole;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.session.Publication" id="apidoc.element.autobahn.session.Publication">
        function <span class="apidocSignatureSpan">autobahn.session.</span>Publication
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Publication = function (id) {

   var self = this;
   self.id = id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.session.Registration" id="apidoc.element.autobahn.session.Registration">
        function <span class="apidocSignatureSpan">autobahn.session.</span>Registration
        <span class="apidocSignatureSpan">(procedure, endpoint, options, session, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Registration = function (procedure, endpoint, options, session, id) {

   var self = this;

   self.procedure = procedure;
   self.endpoint = endpoint;
   self.options = options || {};
   self.session = session;
   self.id = id;

   self.active = true;

   // this will fire when the endpoint is unregistered
   self._on_unregister = session._defer();

   if (self._on_unregister.promise.then) {
      // whenjs has the actual user promise in an attribute
      self.on_unregister = self._on_unregister.promise;
   } else {
      self.on_unregister = self._on_unregister;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.session.Result" id="apidoc.element.autobahn.session.Result">
        function <span class="apidocSignatureSpan">autobahn.session.</span>Result
        <span class="apidocSignatureSpan">(args, kwargs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Result = function (args, kwargs) {

   var self = this;

   self.args = args || [];
   self.kwargs = kwargs || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   connection.onopen = function (session) {

test.log(&#x27;Connected&#x27;);

function add_complex(args, kwargs) {
   test.log(&#x22;add_complex()&#x22;, args, kwargs);
   return new autobahn.<span class="apidocCodeKeywordSpan">Result</span>([], {c: args[0] + args[2], ci: args[1] + args[3]});
}

function split_name(args) {
   test.log(&#x22;split_name()&#x22;, args);
   return new autobahn.Result(args[0].split(&#x22; &#x22;));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.session.Session" id="apidoc.element.autobahn.session.Session">
        function <span class="apidocSignatureSpan">autobahn.session.</span>Session
        <span class="apidocSignatureSpan">(socket, defer, onchallenge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Session = function (socket, defer, onchallenge) {

   var self = this;

   // the transport connection (WebSocket object)
   self._socket = socket;

   // the Deferred factory to use
   self._defer = defer;

   // the WAMP authentication challenge handler
   self._onchallenge = onchallenge;

   // the WAMP session ID
   self._id = null;

   // the WAMP realm joined
   self._realm = null;

   // the WAMP features in use
   self._features = null;

   // closing state
   self._goodbye_sent = false;
   self._transport_is_closing = false;

   // outstanding requests;
   self._publish_reqs = {};
   self._subscribe_reqs = {};
   self._unsubscribe_reqs = {};
   self._call_reqs = {};
   self._register_reqs = {};
   self._unregister_reqs = {};

   // subscriptions in place;
   self._subscriptions = {};

   // registrations in place;
   self._registrations = {};

   // incoming invocations;
   self._invocations = {};

   // prefix shortcuts for URIs
   self._prefixes = {};

   // the defaults for &#x27;disclose_me&#x27;
   self._caller_disclose_me = false;
   self._publisher_disclose_me = false;

   self._send_wamp = function (msg) {
      log.debug(msg);
      // forward WAMP message to be sent to WAMP transport
      self._socket.send(msg);
   };


   self._protocol_violation = function (reason) {
      log.warn(&#x22;failing transport due to protocol violation: &#x22; + reason);
      self._socket.close(1002, &#x22;protocol violation: &#x22; + reason);
   };

   self._MESSAGE_MAP = {};
   self._MESSAGE_MAP[MSG_TYPE.ERROR] = {};


   self._process_SUBSCRIBED = function (msg) {
      //
      // process SUBSCRIBED reply to SUBSCRIBE
      //
      var request = msg[1];
      var subscription = msg[2];

      if (request in self._subscribe_reqs) {

         var r = self._subscribe_reqs[request];

         var d = r[0];
         var topic = r[1];
         var handler = r[2];
         var options = r[3];

         if (!(subscription in self._subscriptions)) {
            self._subscriptions[subscription] = [];
         }
         var sub = new Subscription(topic, handler, options, self, subscription);
         self._subscriptions[subscription].push(sub);

         d.resolve(sub);

         delete self._subscribe_reqs[request];

      } else {
         self._protocol_violation(&#x22;SUBSCRIBED received for non-pending request ID &#x22; + request);
      }
   };
   self._MESSAGE_MAP[MSG_TYPE.SUBSCRIBED] = self._process_SUBSCRIBED;


   self._process_SUBSCRIBE_ERROR = function (msg) {
      //
      // process ERROR reply to SUBSCRIBE
      //
      var request = msg[2];
      if (request in self._subscribe_reqs) {

         var details = msg[3];
         var error = new Error(msg[4], msg[5], msg[6]);

         var r = self._subscribe_reqs[request];

         var d = r[0];

         d.reject(error);

         delete self._subscribe_reqs[request];

      } else {
         self._protocol_violation(&#x22;SUBSCRIBE-ERROR received for non-pending request ID &#x22; + request);
      }
   };
   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.SUBSCRIBE] = self._process_SUBSCRIBE_ERROR;


   self._process_UNSUBSCRIBED = function (msg) {
      //
      // process UNSUBSCRIBED reply to UNSUBSCRIBE
      //
      var request = msg[1];

      if (request in self._unsubscribe_reqs) {

         var r = self._unsubscribe_reqs[request];

         var d = r[0];
         var subscription_id = r[1];

         if (subscription_id in self._subscriptions) {
            var subs = self._subscriptions[subscription_id];
            // the following should actually be NOP, since UNSUBSCRIBE was
            // only sent when subs got empty
            for (var i = 0; i &#x3c; subs.length; ++i) {
               subs[i].active = false;
               subs[i].on_unsubscribe.resolve();
            }
            delete self._subscriptions[subscription_id];
         }

         d.resolve(true);

         delete self._unsubscribe_reqs[request];

      } else {

         if (request === 0) {

            // router actively revoked our subscription
            //
            var details = msg[2];
            var subscription_id = details.sub ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   };
   self.onclose(&#x22;unsupported&#x22;, details);
}
return;
      }

      // create a new WAMP session using the WebSocket connection as transport
      self._session = new session.<span class="apidocCodeKeywordSpan">Session</span>(self._transport, self._defer, self._options
.onchallenge);
      self._session_close_reason = null;
      self._session_close_message = null;

      self._transport.onopen = function () {

// reset auto-reconnect timer and tracking
self._autoreconnect_reset();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.session.Subscription" id="apidoc.element.autobahn.session.Subscription">
        function <span class="apidocSignatureSpan">autobahn.session.</span>Subscription
        <span class="apidocSignatureSpan">(topic, handler, options, session, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Subscription = function (topic, handler, options, session, id) {

   var self = this;

   self.topic = topic;
   self.handler = handler;
   self.options = options || {};
   self.session = session;
   self.id = id;

   self.active = true;

   // this will fire when the handler is unsubscribed
   self._on_unsubscribe = session._defer();

   if (self._on_unsubscribe.promise.then) {
      // whenjs has the actual user promise in an attribute
      self.on_unsubscribe = self._on_unsubscribe.promise;
   } else {
      self.on_unsubscribe = self._on_unsubscribe;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.util" id="apidoc.module.autobahn.util">module autobahn.util</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.util.assert" id="apidoc.element.autobahn.util.assert">
        function <span class="apidocSignatureSpan">autobahn.util.</span>assert
        <span class="apidocSignatureSpan">(cond, text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assert = function (cond, text) {
	if (cond) {
      return;
   }
	if (assert.useDebugger || (&#x27;AUTOBAHN_DEBUG&#x27; in global &#x26;&#x26; AUTOBAHN_DEBUG)) {
      debugger;
   }

	throw new Error(text || &#x22;Assertion failed!&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


Connection.prototype._init_transport_factories = function () {
// WAMP transport
//
var transports, transport_options, transport_factory, transport_factory_klass;

util.<span class="apidocCodeKeywordSpan">assert</span>(this._options.transports, &#x22;No transport.factory specified&#x22;);
transports = this._options.transports;
//if(typeof transports === &#x22;object&#x22;) {
//    this._options.transports = [transports];
//}
for(var i = 0; i &#x3c; this._options.transports.length; ++i) {
    // cascading transports until we find one which works
    transport_options =  this._options.transports[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.util.defaults" id="apidoc.element.autobahn.util.defaults">
        function <span class="apidocSignatureSpan">autobahn.util.</span>defaults
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function () {
   // Return an empty object if no arguments are passed
   if (arguments.length === 0) return {};

   var base = arguments[0];
   var recursive = false;
   var len = arguments.length;

   // Check for recursive mode param
   if (typeof arguments[len - 1] === &#x27;boolean&#x27;) {
      recursive = arguments[len - 1];
      len -= 1; // Ignore the last arg
   }

   // Merging function used by Array#forEach()
   var do_merge = function (key) {
      var val = obj[key];

      // Set if unset
      if (!(key in base)) {
         base[key] = val;
      // If the value is an object and we use recursive mode, use defaults on
      // the value
      } else if (recursive &#x26;&#x26; typeof val === &#x27;object&#x27; &#x26;&#x26;
                 typeof base[key] === &#x27;object&#x27;) {
         defaults(base[key], val);
      }
      // Otherwise ignore the value
   };

   // Iterate over source objects
   for (var i=1; i &#x3c; len; i++) {
      var obj = arguments[i];

      // Ignore falsy values
      if (!obj) continue;

      // Require object
      if (typeof obj !== &#x27;object&#x27;) {
         throw new Error(&#x27;Expected argument at index &#x27; + i +
                         &#x27; to be an object&#x27;);
      }

      // Merge keys
      Object.keys(obj).forEach(do_merge);
   }

   // Return the mutated base object
   return base;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function Protocol (stream, options) {
this._options = {
   _peer_serializer: null, // Will hold the serializer declared by the peer
   _peer_max_len_exp: 0    // Will hold the maximum frame length declared by
                           // the peer
};

this._options = util.<span class="apidocCodeKeywordSpan">defaults</span>(this._options, options, this.DEFAULT_OPTIONS);

// Check valid options
util.assert(this._options.serializer in this.SERIALIZERS,
   &#x27;Unsupported serializer: &#x27; + this._options.serializer);

util.assert(this._options.max_len_exp &#x3e;= 9 &#x26;&#x26;
   this._options.max_len_exp &#x3c;= 36,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.util.http_post" id="apidoc.element.autobahn.util.http_post">
        function <span class="apidocSignatureSpan">autobahn.util.</span>http_post
        <span class="apidocSignatureSpan">(url, data, timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http_post = function (url, data, timeout) {

   log.debug(&#x22;new http_post request&#x22;, url, data, timeout);

   var d = when.defer();
   var req = new XMLHttpRequest();
   req.withCredentials = true; // pass along cookies
   req.onreadystatechange = function () {

      if (req.readyState === 4) {

         // Normalize IE&#x27;s response to HTTP 204 when Win error 1223.
         // http://stackoverflow.com/a/10047236/884770
         //
         var status = (req.status === 1223) ? 204 : req.status;

         if (status === 200) {

            // response with content
            //
            d.resolve(req.responseText);

         } if (status === 204) {

            // empty response
            //
            d.resolve();

         } else {

            // anything else is a fail
            //
            var statusText = null;
            try {
               statusText = req.statusText;
            } catch (e) {
               // IE8 fucks up on this
            }
            d.reject({code: status, text: statusText});
         }
      }
   }

   req.open(&#x22;POST&#x22;, url, true);
   req.setRequestHeader(&#x22;Content-type&#x22;, &#x22;application/json; charset=utf-8&#x22;);

   if (timeout &#x3e; 0) {
      req.timeout = timeout; // request timeout in ms

      req.ontimeout = function () {
         d.reject({code: 501, text: &#x22;request timeout&#x22;});
      }
   }

   if (data) {
      req.send(data);
   } else {
      req.send();
   }

   if (d.promise.then) {
      // whenjs has the actual user promise in an attribute
      return d.promise;
   } else {
      return d;
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      var txseq = 0;
      var rxseq = 0;

      var options = {&#x27;protocols&#x27;: [&#x27;wamp.2.json&#x27;]};
      var request_timeout = self._options.request_timeout || 12000; // timeout here &#x3e; than the 10s default in Crossbar.io

      util.<span class="apidocCodeKeywordSpan">http_post</span>(self._options.url + &#x27;/open&#x27;, JSON.stringify(options),
request_timeout).then(

         function (payload) {

session_info = JSON.parse(payload);
var base_url = self._options.url + &#x27;/&#x27; + session_info.transport;

transport.info.url = base_url;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.util.rand_normal" id="apidoc.element.autobahn.util.rand_normal">
        function <span class="apidocSignatureSpan">autobahn.util.</span>rand_normal
        <span class="apidocSignatureSpan">(mean, sd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rand_normal = function (mean, sd) {
   // Derive a Gaussian from Uniform random variables
   // http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
   var x1, x2, rad;

   do {
      x1 = 2 * Math.random() - 1;
      x2 = 2 * Math.random() - 1;
      rad = x1 * x1 + x2 * x2;
   } while (rad &#x3e;= 1 || rad == 0);

   var c = Math.sqrt(-2 * Math.log(rad) / rad);

   return (mean || 0) + (x1 * c) * (sd || 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Connection.prototype._autoreconnect_advance = function () {

var self = this;

// jitter retry delay
if (self._retry_delay_jitter) {
   self._retry_delay = util.<span class="apidocCodeKeywordSpan">rand_normal</span>(self._retry_delay, self._retry_delay * self._retry_delay_jitter
);
}

// cap the retry delay
if (self._retry_delay &#x3e; self._max_retry_delay) {
   self._retry_delay = self._max_retry_delay;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.websocket" id="apidoc.module.autobahn.websocket">module autobahn.websocket</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.websocket.Factory" id="apidoc.element.autobahn.websocket.Factory">
        function <span class="apidocSignatureSpan">autobahn.websocket.</span>Factory
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Factory(options) {
   var self = this;

   util.assert(options.url !== undefined, &#x22;options.url missing&#x22;);
   util.assert(typeof options.url === &#x22;string&#x22;, &#x22;options.url must be a string&#x22;);

   if (!options.serializers) {
      options.serializers = [new serializer.JSONSerializer()];
      if (serializer.MsgpackSerializer) {
         options.serializers.push(new serializer.MsgpackSerializer());
      }
   } else {
      util.assert(Array.isArray(options.serializers), &#x22;options.serializers must be an array&#x22;);
   }

   if (!options.protocols) {
      options.protocols = [];
      options.serializers.forEach(function (ser) {
         options.protocols.push(&#x22;wamp.2.&#x22; + ser.SERIALIZER_ID);
      });
   } else {
      util.assert(Array.isArray(options.protocols), &#x22;options.protocols must be an array&#x22;);
   }

   self._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.when" id="apidoc.module.autobahn.when">module autobahn.when</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.when.when" id="apidoc.element.autobahn.when.when">
        function <span class="apidocSignatureSpan">autobahn.</span>when
        <span class="apidocSignatureSpan">(x, onFulfilled, onRejected, onProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length &#x3c; 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise" id="apidoc.element.autobahn.when.Promise">
        function <span class="apidocSignatureSpan">autobahn.when.</span>Promise
        <span class="apidocSignatureSpan">(resolver, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.TimeoutError" id="apidoc.element.autobahn.when.TimeoutError">
        function <span class="apidocSignatureSpan">autobahn.when.</span>TimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === &#x27;function&#x27;) {
			Error.captureStackTrace(this, TimeoutError);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.all" id="apidoc.element.autobahn.when.all">
        function <span class="apidocSignatureSpan">autobahn.when.</span>all
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all(promises) {
		return when(promises, Promise.all);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
testcase.expect(1);

var test = new testutil.Testlog(&#x22;test/test_basic_async.txt&#x22;);

var d1 = autobahn.when.defer();
var d2 = autobahn.when.defer();

var df = autobahn.when.<span class="apidocCodeKeywordSpan">all</span>([d1.promise, d2.promise]).then(
   function (res) {
      test.log(res);
      var chk = test.check();
      testcase.ok(!chk, chk);
      testcase.done();
   },
   function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.any" id="apidoc.element.autobahn.when.any">
        function <span class="apidocSignatureSpan">autobahn.when.</span>any
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">any = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&#x3c;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.attempt" id="apidoc.element.autobahn.when.attempt">
        function <span class="apidocSignatureSpan">autobahn.when.</span>attempt
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attempt(f) {
		<span class="apidocCodeCommentSpan">/*jshint validthis:true */
</span>		for(var i=0, l=arguments.length-1, a=new Array(l); i&#x3c;l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.defer" id="apidoc.element.autobahn.when.defer">
        function <span class="apidocSignatureSpan">autobahn.when.</span>defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defer() {
		return new Deferred();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    Connection.Deferred

returns the Deferred factory function used by the connection.

A Deferred factory for the type of Deferreds (whenjs, ES6, jQuery or Q) in use with the connection:

    Connection.<span class="apidocCodeKeywordSpan">defer</span>()

which returns a Deffered of the type specified in the call to the connection constructor.


Sessions
========
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.filter" id="apidoc.element.autobahn.when.filter">
        function <span class="apidocSignatureSpan">autobahn.when.</span>filter
        <span class="apidocSignatureSpan">(promises, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.isPromiseLike" id="apidoc.element.autobahn.when.isPromiseLike">
        function <span class="apidocSignatureSpan">autobahn.when.</span>isPromiseLike
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPromiseLike(x) {
		return x &#x26;&#x26; typeof x.then === &#x27;function&#x27;;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.iterate" id="apidoc.element.autobahn.when.iterate">
        function <span class="apidocSignatureSpan">autobahn.when.</span>iterate
        <span class="apidocSignatureSpan">(f, condition, handler, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.join" id="apidoc.element.autobahn.when.join">
        function <span class="apidocSignatureSpan">autobahn.when.</span>join
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function join() {
		return Promise.all(arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

env[&#x27;JS_DEFINES&#x27;] = {
#   &#x27;AUTOBAHNJS_VERSION&#x27;: &#x22;&#x27;%s&#x27;&#x22; % version
}

# Source for Autobahn package
sourcedir = &#x27;lib&#x27;
sources = [os.path.<span class="apidocCodeKeywordSpan">join</span>(sourcedir, d) for d in os.listdir(sourcedir)]

# browserified
ab = env.Command(&#x22;build/autobahn.js&#x22;,
                 &#x22;lib/autobahn.js&#x22;,
                 &#x22;/usr/local/lib/node_modules/browserify/bin/cmd.js $SOURCE --ignore-missing --standalone autobahn -o $TARGET
&#x22;)
Depends(ab, sources)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.lift" id="apidoc.element.autobahn.when.lift">
        function <span class="apidocSignatureSpan">autobahn.when.</span>lift
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i&#x3c;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.map" id="apidoc.element.autobahn.when.map">
        function <span class="apidocSignatureSpan">autobahn.when.</span>map
        <span class="apidocSignatureSpan">(promises, mapFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.promise" id="apidoc.element.autobahn.when.promise">
        function <span class="apidocSignatureSpan">autobahn.when.</span>promise
        <span class="apidocSignatureSpan">(resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promise(resolver) {
		return new Promise(resolver);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.race" id="apidoc.element.autobahn.when.race">
        function <span class="apidocSignatureSpan">autobahn.when.</span>race
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">race = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&#x3c;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.reduce" id="apidoc.element.autobahn.when.reduce">
        function <span class="apidocSignatureSpan">autobahn.when.</span>reduce
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduce = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&#x3c;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.reduceRight" id="apidoc.element.autobahn.when.reduceRight">
        function <span class="apidocSignatureSpan">autobahn.when.</span>reduceRight
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduceRight = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&#x3c;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.reject" id="apidoc.element.autobahn.when.reject">
        function <span class="apidocSignatureSpan">autobahn.when.</span>reject
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var details = msg[3];
      var error = new Error(msg[4], msg[5], msg[6]);

      var r = self._subscribe_reqs[request];

      var d = r[0];

      d.<span class="apidocCodeKeywordSpan">reject</span>(error);

      delete self._subscribe_reqs[request];

   } else {
      self._protocol_violation(&#x22;SUBSCRIBE-ERROR received for non-pending request ID &#x22; + request);
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.resolve" id="apidoc.element.autobahn.when.resolve">
        function <span class="apidocSignatureSpan">autobahn.when.</span>resolve
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` js
session.prefix(&#x27;api&#x27;, null);
```

To resolve a prefix *(normally not needed in user code)*:

``` js
session.<span class="apidocCodeKeywordSpan">resolve</span>(&#x27;api:add2&#x27;);
```

Session Meta-Events &#x26; Procedures
--------------------------------

Some WAMP routers (such as [Crossbar.io](http://crossbar.io)) provide the possibility to subscribe to events which are created by
 the router based on session lifecycle, as well as procedures which allow the retrieval of information about current sessions. For
 more information see the [Crossbar.io documenation](http://crossbar.io/docs/Session-Metaevents-and-Procedures/).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.settle" id="apidoc.element.autobahn.when.settle">
        function <span class="apidocSignatureSpan">autobahn.when.</span>settle
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function settle(promises) {
		return when(promises, Promise.settle);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.some" id="apidoc.element.autobahn.when.some">
        function <span class="apidocSignatureSpan">autobahn.when.</span>some
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&#x3c;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.try" id="apidoc.element.autobahn.when.try">
        function <span class="apidocSignatureSpan">autobahn.when.</span>try
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attempt(f) {
		<span class="apidocCodeCommentSpan">/*jshint validthis:true */
</span>		for(var i=0, l=arguments.length-1, a=new Array(l); i&#x3c;l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.unfold" id="apidoc.element.autobahn.when.unfold">
        function <span class="apidocSignatureSpan">autobahn.when.</span>unfold
        <span class="apidocSignatureSpan">(unspool, condition, handler, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.when.Promise" id="apidoc.module.autobahn.when.Promise">module autobahn.when.Promise</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.Promise" id="apidoc.element.autobahn.when.Promise.Promise">
        function <span class="apidocSignatureSpan">autobahn.when.</span>Promise
        <span class="apidocSignatureSpan">(resolver, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise._defer" id="apidoc.element.autobahn.when.Promise._defer">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>_defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defer() {
			return new Promise(Handler, new Pending());
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.options = options || {};
self.session = session;
self.id = id;

self.active = true;

// this will fire when the handler is unsubscribed
self._on_unsubscribe = session.<span class="apidocCodeKeywordSpan">_defer</span>();

if (self._on_unsubscribe.promise.then) {
   // whenjs has the actual user promise in an attribute
   self.on_unsubscribe = self._on_unsubscribe.promise;
} else {
   self.on_unsubscribe = self._on_unsubscribe;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise._handler" id="apidoc.element.autobahn.when.Promise._handler">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>_handler
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise._traverse" id="apidoc.element.autobahn.when.Promise._traverse">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>_traverse
        <span class="apidocSignatureSpan">(f, promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise._visitRemaining" id="apidoc.element.autobahn.when.Promise._visitRemaining">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>_visitRemaining
        <span class="apidocSignatureSpan">(promises, start, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visitRemaining(promises, start, handler) {
			for(var i=start; i&#x3c;promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.all" id="apidoc.element.autobahn.when.Promise.all">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>all
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all(promises) {
			return traverseWith(snd, null, promises);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
testcase.expect(1);

var test = new testutil.Testlog(&#x22;test/test_basic_async.txt&#x22;);

var d1 = autobahn.when.defer();
var d2 = autobahn.when.defer();

var df = autobahn.when.<span class="apidocCodeKeywordSpan">all</span>([d1.promise, d2.promise]).then(
   function (res) {
      test.log(res);
      var chk = test.check();
      testcase.ok(!chk, chk);
      testcase.done();
   },
   function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.any" id="apidoc.element.autobahn.when.Promise.any">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>any
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length&#x3e;&#x3e;&#x3e;0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i &#x3c; l; ++i) {
				x = promises[i];
				if(x === void 0 &#x26;&#x26; !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() &#x3e; 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError(&#x27;any(): array must not be empty&#x27;));
			}

			return p;

			function handleFulfill(x) {
				<span class="apidocCodeCommentSpan">/*jshint validthis:true*/
</span>				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.createContext" id="apidoc.element.autobahn.when.Promise.createContext">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>createContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.enterContext" id="apidoc.element.autobahn.when.Promise.enterContext">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>enterContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.exitContext" id="apidoc.element.autobahn.when.Promise.exitContext">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>exitContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.filter" id="apidoc.element.autobahn.when.Promise.filter">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>filter
        <span class="apidocSignatureSpan">(promises, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.iterate" id="apidoc.element.autobahn.when.Promise.iterate">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>iterate
        <span class="apidocSignatureSpan">(f, condition, handler, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.map" id="apidoc.element.autobahn.when.Promise.map">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>map
        <span class="apidocSignatureSpan">(promises, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(promises, f) {
			return Promise._traverse(f, promises);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.never" id="apidoc.element.autobahn.when.Promise.never">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>never
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function never() {
			return foreverPendingPromise; // Should be frozen
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.onFatalRejection" id="apidoc.element.autobahn.when.Promise.onFatalRejection">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>onFatalRejection
        <span class="apidocSignatureSpan">(rejection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onFatalRejection = function (rejection) {
			enqueue(throwit, rejection.value);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.onPotentiallyUnhandledRejection" id="apidoc.element.autobahn.when.Promise.onPotentiallyUnhandledRejection">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>onPotentiallyUnhandledRejection
        <span class="apidocSignatureSpan">(rejection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onPotentiallyUnhandledRejection = function (rejection) {
			enqueue(report, rejection);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.onPotentiallyUnhandledRejectionHandled" id="apidoc.element.autobahn.when.Promise.onPotentiallyUnhandledRejectionHandled">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>onPotentiallyUnhandledRejectionHandled
        <span class="apidocSignatureSpan">(rejection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onPotentiallyUnhandledRejectionHandled = function (rejection) {
			enqueue(unreport, rejection);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.race" id="apidoc.element.autobahn.when.Promise.race">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>race
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(promises) {
			if(typeof promises !== &#x27;object&#x27; || promises === null) {
				return reject(new TypeError(&#x27;non-iterable passed to race()&#x27;));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.reduce" id="apidoc.element.autobahn.when.Promise.reduce">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>reduce
        <span class="apidocSignatureSpan">(promises, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(promises, f) {
			return arguments.length &#x3e; 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.reduceRight" id="apidoc.element.autobahn.when.Promise.reduceRight">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>reduceRight
        <span class="apidocSignatureSpan">(promises, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(promises, f) {
			return arguments.length &#x3e; 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.reject" id="apidoc.element.autobahn.when.Promise.reject">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>reject
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var details = msg[3];
      var error = new Error(msg[4], msg[5], msg[6]);

      var r = self._subscribe_reqs[request];

      var d = r[0];

      d.<span class="apidocCodeKeywordSpan">reject</span>(error);

      delete self._subscribe_reqs[request];

   } else {
      self._protocol_violation(&#x22;SUBSCRIBE-ERROR received for non-pending request ID &#x22; + request);
   }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.resolve" id="apidoc.element.autobahn.when.Promise.resolve">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>resolve
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` js
session.prefix(&#x27;api&#x27;, null);
```

To resolve a prefix *(normally not needed in user code)*:

``` js
session.<span class="apidocCodeKeywordSpan">resolve</span>(&#x27;api:add2&#x27;);
```

Session Meta-Events &#x26; Procedures
--------------------------------

Some WAMP routers (such as [Crossbar.io](http://crossbar.io)) provide the possibility to subscribe to events which are created by
 the router based on session lifecycle, as well as procedures which allow the retrieval of information about current sessions. For
 more information see the [Crossbar.io documenation](http://crossbar.io/docs/Session-Metaevents-and-Procedures/).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.settle" id="apidoc.element.autobahn.when.Promise.settle">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>settle
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function settle(promises) {
			return all(promises.map(settleOne));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.some" id="apidoc.element.autobahn.when.Promise.some">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>some
        <span class="apidocSignatureSpan">(promises, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some(promises, n) {
			<span class="apidocCodeCommentSpan">/*jshint maxcomplexity:7*/
</span>			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length&#x3e;&#x3e;&#x3e;0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i&#x3c;l; ++i) {
				x = promises[i];
				if(x === void 0 &#x26;&#x26; !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n &#x3e; nFulfill) {
				resolver.reject(new RangeError(&#x27;some(): array must contain at least &#x27;
				+ n + &#x27; item(s), but had &#x27; + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i&#x3c;l; ++i) {
				x = promises[i];
				if(x === void 0 &#x26;&#x26; !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.unfold" id="apidoc.element.autobahn.when.Promise.unfold">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.</span>unfold
        <span class="apidocSignatureSpan">(unspool, condition, handler, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.when.Promise.prototype" id="apidoc.module.autobahn.when.Promise.prototype">module autobahn.when.Promise.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype._beget" id="apidoc.element.autobahn.when.Promise.prototype._beget">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>_beget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_beget = function () {
			return begetFrom(this._handler, this.constructor);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.catch" id="apidoc.element.autobahn.when.Promise.prototype.catch">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>catch
        <span class="apidocSignatureSpan">(onRejected)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (onRejected) {
			if (arguments.length &#x3c; 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== &#x27;function&#x27;) {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.delay" id="apidoc.element.autobahn.when.Promise.prototype.delay">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>delay
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.done" id="apidoc.element.autobahn.when.Promise.prototype.done">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>done
        <span class="apidocSignatureSpan">(onResult, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">done = function (onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var d2 = autobahn.when.defer();

var df = autobahn.when.all([d1.promise, d2.promise]).then(
   function (res) {
      test.log(res);
      var chk = test.check();
      testcase.ok(!chk, chk);
      testcase.<span class="apidocCodeKeywordSpan">done</span>();
   },
   function (err) {
      test.log(err);
      testcase.done();
   }
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.else" id="apidoc.element.autobahn.when.Promise.prototype.else">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>else
        <span class="apidocSignatureSpan">(defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">else = function (defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.ensure" id="apidoc.element.autobahn.when.Promise.prototype.ensure">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>ensure
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensure = function (handler) {
			if(typeof handler !== &#x27;function&#x27;) {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.finally" id="apidoc.element.autobahn.when.Promise.prototype.finally">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>finally
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finally = function (handler) {
			if(typeof handler !== &#x27;function&#x27;) {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.fold" id="apidoc.element.autobahn.when.Promise.prototype.fold">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>fold
        <span class="apidocSignatureSpan">(f, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fold = function (f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.inspect" id="apidoc.element.autobahn.when.Promise.prototype.inspect">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
			return inspect(Promise._handler(this));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.orElse" id="apidoc.element.autobahn.when.Promise.prototype.orElse">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>orElse
        <span class="apidocSignatureSpan">(defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">orElse = function (defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.otherwise" id="apidoc.element.autobahn.when.Promise.prototype.otherwise">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>otherwise
        <span class="apidocSignatureSpan">(onRejected)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">otherwise = function (onRejected) {
			if (arguments.length &#x3c; 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== &#x27;function&#x27;) {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.progress" id="apidoc.element.autobahn.when.Promise.prototype.progress">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>progress
        <span class="apidocSignatureSpan">(onProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">progress = function (onProgress) {
			return this.then(void 0, void 0, onProgress);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Here a third callback has been added, which is fired on each receipt of a progressive result event.

In the backend, the function for returning progressive results could be something like

``` js
if (details.progress) {
   for (var i = 0; i &#x3c; 5; i++) {
      details.<span class="apidocCodeKeywordSpan">progress</span>(i);
   }
   return &#x22;progressive result&#x22;
} else {
   return &#x22;single result&#x22;;
}
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.spread" id="apidoc.element.autobahn.when.Promise.prototype.spread">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>spread
        <span class="apidocSignatureSpan">(onFulfilled)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spread = function (onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.tap" id="apidoc.element.autobahn.when.Promise.prototype.tap">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>tap
        <span class="apidocSignatureSpan">(onFulfilledSideEffect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tap = function (onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)[&#x27;yield&#x27;](this);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.then" id="apidoc.element.autobahn.when.Promise.prototype.then">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>then
        <span class="apidocSignatureSpan">(onFulfilled, onRejected, onProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== &#x27;function&#x27; &#x26;&#x26; state &#x3e; 0) ||
				(typeof onRejected !== &#x27;function&#x27; &#x26;&#x26; state &#x3c; 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // 3) register a procedure for remoting
   function add2(args) {
      return args[0] + args[1];
   }
   session.register(&#x27;com.myapp.add2&#x27;, add2);

   // 4) call a remote procedure
   session.call(&#x27;com.myapp.add2&#x27;, [2, 3]).<span class="apidocCodeKeywordSpan">then</span>(
      function (res) {
         console.log(&#x22;Result:&#x22;, res);
      }
   );
};

connection.open();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.timeout" id="apidoc.element.autobahn.when.Promise.prototype.timeout">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>timeout
        <span class="apidocSignatureSpan">(ms, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeout = function (ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.with" id="apidoc.element.autobahn.when.Promise.prototype.with">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>with
        <span class="apidocSignatureSpan">(receiver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">with = function (receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.withThis" id="apidoc.element.autobahn.when.Promise.prototype.withThis">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>withThis
        <span class="apidocSignatureSpan">(receiver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withThis = function (receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.autobahn.when.Promise.prototype.yield" id="apidoc.element.autobahn.when.Promise.prototype.yield">
        function <span class="apidocSignatureSpan">autobahn.when.Promise.prototype.</span>yield
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yield = function (value) {
			return this.then(function() {
				return value;
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.when.TimeoutError" id="apidoc.module.autobahn.when.TimeoutError">module autobahn.when.TimeoutError</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.when.TimeoutError.TimeoutError" id="apidoc.element.autobahn.when.TimeoutError.TimeoutError">
        function <span class="apidocSignatureSpan">autobahn.when.</span>TimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === &#x27;function&#x27;) {
			Error.captureStackTrace(this, TimeoutError);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.autobahn.when.TimeoutError.prototype" id="apidoc.module.autobahn.when.TimeoutError.prototype">module autobahn.when.TimeoutError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.autobahn.when.TimeoutError.prototype.constructor" id="apidoc.element.autobahn.when.TimeoutError.prototype.constructor">
        function <span class="apidocSignatureSpan">autobahn.when.TimeoutError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === &#x27;function&#x27;) {
			Error.captureStackTrace(this, TimeoutError);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var res = [];
    var thisp = arguments[1];
    for (var i = 0; i &#x3c; len; i++) {
        var val = t._getter(i); // in case fun mutates this
        if (callbackfn.call(thisp, val, i, t))
            res.push(val);
    }
    return new this.<span class="apidocCodeKeywordSpan">constructor</span>(res);
}});

// %TypedArray%.prototype.find (predicate, thisArg = undefined)
Object.defineProperty($TypedArray$.prototype, &#x27;find&#x27;, {value: function (predicate) {
    var o = ToObject(this);
    var lenValue = o.length;
    var len = ToUint32(lenValue);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
